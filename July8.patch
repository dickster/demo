Index: src/main/java/demo/EasyName.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/EasyName.java	(revision )
+++ src/main/java/demo/EasyName.java	(revision )
@@ -0,0 +1,134 @@
+package demo;
+
+import com.google.gson.*;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.wicket.ajax.AbstractDefaultAjaxBehavior;
+import org.apache.wicket.ajax.AjaxRequestTarget;
+import org.apache.wicket.markup.head.IHeaderResponse;
+import org.apache.wicket.markup.head.JavaScriptHeaderItem;
+import org.apache.wicket.markup.head.OnDomReadyHeaderItem;
+import org.apache.wicket.markup.html.form.TextField;
+import org.apache.wicket.model.IModel;
+import org.apache.wicket.request.IRequestParameters;
+import org.apache.wicket.request.cycle.RequestCycle;
+import org.apache.wicket.request.resource.CssResourceReference;
+import org.apache.wicket.request.resource.JavaScriptResourceReference;
+import org.apache.wicket.util.convert.ConversionException;
+import org.apache.wicket.util.convert.IConverter;
+import org.apache.wicket.util.convert.converter.AbstractConverter;
+
+import java.lang.reflect.Type;
+import java.util.Locale;
+
+public class EasyName extends TextField<Name> {
+
+    // TODO DD : make this a generic behavior that handles JSON form desc = {label:{'a','b','c'}, label2:{'x','y','z'}, etc.. }    did you mean?   or maybe this? -->
+    private static final String DID_YOU_MEAN_JS = "$('#%s').data('nameWidget').didYouMean(%s);";
+
+    private static final String EASY_NAME_INIT_JS = "easy.name.create(%s);";
+    private static final JavaScriptResourceReference NAME_JS = new JavaScriptResourceReference(EasyName.class,"name.js");
+
+    private final AbstractDefaultAjaxBehavior behavior;
+
+    private IConverter<Name> nameConverter = new NameConverter();
+
+
+    public EasyName(String id, IModel<Name> model) {
+        super(id,model);
+        setOutputMarkupId(true);
+        add(behavior = new AbstractDefaultAjaxBehavior() {
+            // TODO : need to make sure this is called before form is submitted??
+            // e.g. if user types in name then clicks on submit button will the change event be fired? before or after submit is called?
+            @Override protected void respond(AjaxRequestTarget target) {
+                IRequestParameters params = RequestCycle.get().getRequest().getRequestParameters();
+                String text = params.getParameterValue("text").toString();
+                validateName(text, target);
+            }
+        });
+    }
+
+    @Override
+    public <C> IConverter<C> getConverter(Class<C> type) {
+        return (type.equals(Name.class)) ?
+            (IConverter<C>) nameConverter :
+                super.getConverter(type);
+    }
+
+    @Override
+    public void renderHead(IHeaderResponse response) {
+        response.render(JavaScriptHeaderItem.forReference(NAME_JS));
+        response.render(OnDomReadyHeaderItem.forScript(String.format(EASY_NAME_INIT_JS, new Gson().toJson(new NameOptions()))));
+    }
+
+    private void validateName(String text, AjaxRequestTarget target) {
+        try {
+            Name name = nameConverter.convertToObject(text, Locale.getDefault());
+            if (name.isAmbiguous()) {
+                target.appendJavaScript(didYouMean(name));
+            }
+        } catch (ConversionException e) {
+            target.appendJavaScript(didYouMean(bestGuess(text)));
+        }
+    }
+
+    private String didYouMean(Name name) {
+        if (name==null) {
+            name=new Name();
+        }
+        Gson gson = new GsonBuilder().registerTypeAdapter(Name.class,new NameAdapter()).create();
+        return String.format(DID_YOU_MEAN_JS, getMarkupId(), gson.toJson(name));
+    }
+
+    private Name bestGuess(String text) {
+        String[] tokens = text.split(" ");
+        if (tokens.length==3) {
+            return new Name().withFirstName(tokens[0]).withMiddleName(tokens[1]).withLastName(tokens[2]);
+        } else if (tokens.length==2) {
+            return new Name().withFirstName(tokens[0]).withMiddleName("").withLastName(tokens[1]);
+        } else {
+            return new Name().withFirstName(tokens[0]).withMiddleName("").withLastName(text.substring(tokens[0].length()).trim());
+        }
+    }
+
+    class NameOptions {
+        String id = EasyName.this.getMarkupId();
+        String callback = behavior.getCallbackUrl().toString();
+    }
+
+    class NameAdapter implements JsonSerializer<Name> {
+
+        @Override
+        public JsonElement serialize(Name name, Type typeOfSrc, JsonSerializationContext context) {
+            JsonObject object = new JsonObject();
+            object.addProperty("first", name.getFirst());
+            object.addProperty("middle", name.getMiddle());
+            object.addProperty("last", name.getLast());
+            return object;
+        }
+    }
+
+    class NameConverter extends AbstractConverter<Name> {
+
+        private transient NameParser parser = new NameParser();
+
+        NameConverter() {
+        }
+
+        @Override
+        protected Class getTargetType() {
+            return Name.class;
+        }
+
+        @Override
+        public Name convertToObject(String text, Locale locale) throws ConversionException {
+            try {
+                return StringUtils.isBlank(text) ?
+                    new Name() :
+                    parser.parseName(text).peek();
+            } catch (Throwable t) {
+                throw new ConversionException("can't parse " + text, t.getCause());
+            }
+        }
+    }
+
+}
Index: src/main/java/demo/Typeahead.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/Typeahead.java	(revision )
+++ src/main/java/demo/Typeahead.java	(revision )
@@ -0,0 +1,87 @@
+package demo;
+
+
+import com.google.common.collect.Lists;
+import com.google.gson.Gson;
+import org.apache.wicket.ajax.AbstractDefaultAjaxBehavior;
+import org.apache.wicket.ajax.AjaxRequestTarget;
+import org.apache.wicket.markup.head.IHeaderResponse;
+import org.apache.wicket.markup.head.JavaScriptReferenceHeaderItem;
+import org.apache.wicket.markup.head.OnLoadHeaderItem;
+import org.apache.wicket.markup.html.form.TextField;
+import org.apache.wicket.model.IModel;
+import org.apache.wicket.request.IRequestParameters;
+import org.apache.wicket.request.cycle.RequestCycle;
+import org.apache.wicket.request.handler.TextRequestHandler;
+import org.apache.wicket.request.resource.CssResourceReference;
+import org.apache.wicket.request.resource.JavaScriptResourceReference;
+
+import java.util.List;
+
+public class Typeahead<T> extends TextField<T> {
+
+    private static final String INIT_TYPEAHEAD_JS = "easy.typeahead.init(%s)";
+    private static final JavaScriptResourceReference TYPEAHEAD_JS = new JavaScriptResourceReference(Typeahead.class,"typeahead.js");
+
+    private transient Gson gson = new Gson();
+
+    private AbstractDefaultAjaxBehavior ajaxHandler;
+
+    public Typeahead(String id) {
+        super(id);
+    }
+
+    public Typeahead(String id, Class<T> type) {
+        super(id, type);
+    }
+
+    public Typeahead(String id, IModel<T> model) {
+        super(id, model);
+    }
+
+    public Typeahead(String id, IModel<T> model, Class<T> type) {
+        super(id, model, type);
+    }
+
+    @Override
+    protected void onInitialize() {
+        super.onInitialize();
+        add(ajaxHandler = createAjaxHandler());
+    }
+
+    public AbstractDefaultAjaxBehavior createAjaxHandler() {
+        return new AbstractDefaultAjaxBehavior() {
+            protected void respond(final AjaxRequestTarget target) {
+                IRequestParameters params = RequestCycle.get().getRequest().getRequestParameters();
+                System.out.println(params.getParameterValue("query"));
+                List<String> data = Lists.newArrayList("hello", "goodbye");
+//                data.add(params.getParameterValue("query").toString());
+                TextRequestHandler handler = new TextRequestHandler("application/json","UTF-8", convertToJson(data));
+                RequestCycle.get().scheduleRequestHandlerAfterCurrent(handler);
+            }
+        };
+    }
+
+    private String convertToJson(Object data) {
+        return gson.toJson(data);
+    }
+
+    @Override
+    public void renderHead(IHeaderResponse response) {
+        response.render(JavaScriptReferenceHeaderItem.forReference(TYPEAHEAD_JS));
+        response.render(OnLoadHeaderItem.forScript(initTypeaheadJs()));
+    }
+
+    protected String initTypeaheadJs() {
+        return String.format(INIT_TYPEAHEAD_JS, convertToJson(getOptions()));
+    }
+
+    public TypeAheadOptions getOptions() {
+        return new TypeAheadOptions();
+    }
+
+    public class TypeAheadOptions {
+        String id = Typeahead.this.getMarkupId();
+        String remote =  ajaxHandler.getCallbackUrl() + "?query=%QUERY";
+    }
+}
Index: src/main/java/demo/Address.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/Address.java	(revision )
+++ src/main/java/demo/Address.java	(revision )
@@ -0,0 +1,80 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+
+package demo;
+
+import java.io.Serializable;
+
+public class Address implements Serializable {
+
+    private String streetAddress = "";
+    private String city = "";
+    private String province = "";
+    private String country = "";
+    private String postalCode = "";
+    private GpsLocation gpsLocation;
+    private String formattedAddress;
+
+    public Address() {
+
+    }
+
+    public String getStreetAddress() {
+        return streetAddress;
+    }
+
+    public void setStreetAddress(String streetAddress) {
+        this.streetAddress = streetAddress;
+    }
+
+    public String getCity() {
+        return city;
+    }
+
+    public void setCity(String city) {
+        this.city = city;
+    }
+
+    public String getProvince() {
+        return province;
+    }
+
+    public void setProvince(String province) {
+        this.province = province;
+    }
+
+    public String getCountry() {
+        return country;
+    }
+
+    public void setCountry(String country) {
+        this.country = country;
+    }
+
+    public String getPostalCode() {
+        return postalCode;
+    }
+
+    public void setPostalCode(String postalCode) {
+        this.postalCode = postalCode;
+    }
+
+    public GpsLocation getGpsLocation() {
+        return gpsLocation;
+    }
+
+    public void setGpsLocation(GpsLocation gpsLocation) {
+        this.gpsLocation = gpsLocation;
+    }
+
+    public String getFormattedAddress() {
+        return formattedAddress;
+    }
+
+    public void setFormattedAddress(String formattedAddress) {
+        this.formattedAddress = formattedAddress;
+    }
+}
Index: src/main/java/demo/EasyAddress.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/EasyAddress.java	(revision )
+++ src/main/java/demo/EasyAddress.java	(revision )
@@ -0,0 +1,98 @@
+package demo;
+
+import com.google.gson.GsonBuilder;
+import org.apache.wicket.RuntimeConfigurationType;
+import org.apache.wicket.markup.head.IHeaderResponse;
+import org.apache.wicket.markup.head.JavaScriptHeaderItem;
+import org.apache.wicket.markup.head.JavaScriptReferenceHeaderItem;
+import org.apache.wicket.markup.head.OnDomReadyHeaderItem;
+import org.apache.wicket.markup.html.form.HiddenField;
+import org.apache.wicket.markup.html.form.ILabelProvider;
+import org.apache.wicket.markup.html.form.TextField;
+import org.apache.wicket.markup.html.panel.Panel;
+import org.apache.wicket.model.IModel;
+import org.apache.wicket.model.Model;
+import org.apache.wicket.model.PropertyModel;
+import org.apache.wicket.request.resource.JavaScriptResourceReference;
+import org.apache.wicket.request.resource.ResourceReference;
+
+import java.math.BigDecimal;
+
+public class EasyAddress extends Panel implements ILabelProvider<String> {
+
+    private static final String GOOGLE_MAPS_URL = "https://maps.googleapis.com/maps/api/js?sensor=false";
+    private static final String CREATE_ADDRESS_JS = "easy.address.create(%s);";
+    private static ResourceReference ADDRESS_JS = new JavaScriptResourceReference(EasyAddress.class, "address.js");
+    
+    private IModel<Address> model;
+    private final TextField<String> text;
+    private GpsLocation location;
+
+    public EasyAddress(String id, IModel<Address> model) {
+        super(id, model);
+        this.model = model;
+        setOutputMarkupId(true);
+        
+        // the wicket id's chosen here are chosen to reflect the json properties that are returned by the GoogleMaps API.
+        // to help understand the javascript binding better.
+        // see https://developers.google.com/maps/documentation/geocoding/#ReverseGeocoding
+        add(new HiddenField<String>("administrative_area_level_1", new PropertyModel(model, "province")));
+        add(new HiddenField<String>("locality", new PropertyModel(model, "city")));
+        add(new HiddenField<String>("street_address", new PropertyModel(model, "streetAddress")));
+        add(new HiddenField<String>("postal_code", new PropertyModel(model, "postalCode")));
+            
+        add(text = new TextField<String>("text", new PropertyModel(model, "formattedAddress")));
+        add(new HiddenField<BigDecimal>("latitude", new PropertyModel(model, "gpsLocation.latitude")));
+        add(new HiddenField<BigDecimal>("longitude", new PropertyModel(model, "gpsLocation.latitude")));
+        add(new HiddenField<String>("country", new PropertyModel(model, "country")));
+    }
+
+    @Override
+    public void renderHead(IHeaderResponse response) {
+        super.renderHead(response);
+        response.render(JavaScriptHeaderItem.forUrl(GOOGLE_MAPS_URL));
+        response.render(JavaScriptReferenceHeaderItem.forReference(ADDRESS_JS));
+        response.render(OnDomReadyHeaderItem.forScript(String.format(CREATE_ADDRESS_JS, new GsonBuilder().create().toJson(getOptions()))));
+    }
+
+    protected Object getOptions() {
+        return new Options();
+    }
+
+    @Override
+    public IModel<String> getLabel() {
+        return Model.of("address");
+    }
+
+    @Override
+    public boolean isVisible() {
+        if (super.isVisible()) {
+            return get("text").isVisible();
+        }
+        return false;
+    }
+
+    public EasyAddress setRequired(boolean required) {
+        text.setRequired(required);
+        return this;
+    }
+
+    public class Options {
+        String id = "#"+EasyAddress.this.getMarkupId();
+        Double latitude;
+        Double longitude;
+
+        Options() {
+            if (EasyAddress.this.getApplication().getConfigurationType().equals(RuntimeConfigurationType.DEVELOPMENT) && location==null) {
+                location = new GpsLocation(43.650713, -79.377683);
+                }
+            if (location!=null) {
+                latitude = location.getLatitude().doubleValue();
+                longitude = location.getLongitude().doubleValue();
+            }
+        }
+
+    }
+
+
+}
Index: src/main/java/demo/Token.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/Token.java	(revision )
+++ src/main/java/demo/Token.java	(revision )
@@ -0,0 +1,131 @@
+/* Generated By:JavaCC: Do not edit this line. Token.java Version 5.0 */
+/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
+package demo;
+
+/**
+ * Describes the input token stream.
+ */
+
+public class Token implements java.io.Serializable {
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /**
+   * An integer that describes the kind of this token.  This numbering
+   * system is determined by JavaCCParser, and a table of these numbers is
+   * stored in the file ...Constants.java.
+   */
+  public int kind;
+
+  /** The line number of the first character of this Token. */
+  public int beginLine;
+  /** The column number of the first character of this Token. */
+  public int beginColumn;
+  /** The line number of the last character of this Token. */
+  public int endLine;
+  /** The column number of the last character of this Token. */
+  public int endColumn;
+
+  /**
+   * The string image of the token.
+   */
+  public String image;
+
+  /**
+   * A reference to the next regular (non-special) token from the input
+   * stream.  If this is the last token from the input stream, or if the
+   * token manager has not read tokens beyond this one, this field is
+   * set to null.  This is true only if this token is also a regular
+   * token.  Otherwise, see below for a description of the contents of
+   * this field.
+   */
+  public Token next;
+
+  /**
+   * This field is used to access special tokens that occur prior to this
+   * token, but after the immediately preceding regular (non-special) token.
+   * If there are no such special tokens, this field is set to null.
+   * When there are more than one such special token, this field refers
+   * to the last of these special tokens, which in turn refers to the next
+   * previous special token through its specialToken field, and so on
+   * until the first special token (whose specialToken field is null).
+   * The next fields of special tokens refer to other special tokens that
+   * immediately follow it (without an intervening regular token).  If there
+   * is no such token, this field is null.
+   */
+  public Token specialToken;
+
+  /**
+   * An optional attribute value of the Token.
+   * Tokens which are not used as syntactic sugar will often contain
+   * meaningful values that will be used later on by the compiler or
+   * interpreter. This attribute value is often different from the image.
+   * Any subclass of Token that actually wants to return a non-null value can
+   * override this method as appropriate.
+   */
+  public Object getValue() {
+    return null;
+  }
+
+  /**
+   * No-argument constructor
+   */
+  public Token() {}
+
+  /**
+   * Constructs a new token for the specified Image.
+   */
+  public Token(int kind)
+  {
+    this(kind, null);
+  }
+
+  /**
+   * Constructs a new token for the specified Image and Kind.
+   */
+  public Token(int kind, String image)
+  {
+    this.kind = kind;
+    this.image = image;
+  }
+
+  /**
+   * Returns the image.
+   */
+  public String toString()
+  {
+    return image;
+  }
+
+  /**
+   * Returns a new Token object, by default. However, if you want, you
+   * can create and return subclass objects based on the value of ofKind.
+   * Simply add the cases to the switch for all those special cases.
+   * For example, if you have a subclass of Token called IDToken that
+   * you want to create if ofKind is ID, simply add something like :
+   *
+   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
+   *
+   * to the following switch statement. Then you can cast matchedToken
+   * variable to the appropriate type and use sit in your lexical actions.
+   */
+  public static Token newToken(int ofKind, String image)
+  {
+    switch(ofKind)
+    {
+      default : return new Token(ofKind, image);
+    }
+  }
+
+  public static Token newToken(int ofKind)
+  {
+    return newToken(ofKind, null);
+  }
+
+}
+/* JavaCC - OriginalChecksum=00067f33c7d20ac20f6a7b9917e4e951 (do not edit this line) */
Index: EasyLibrary/src/test/java/com/brovada/easy/widgets/AddressConverterTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- EasyLibrary/src/test/java/com/brovada/easy/widgets/AddressConverterTest.java	(revision )
+++ EasyLibrary/src/test/java/com/brovada/easy/widgets/AddressConverterTest.java	(revision )
@@ -0,0 +1,35 @@
+package com.brovada.easy.widgets;
+
+import com.google.code.geocoder.model.GeocodeResponse;
+import junit.framework.TestCase;
+import org.junit.Test;
+
+public class AddressConverterTest extends TestCase {
+
+    @Test
+    public void test_GeoCoder() {
+        AddressUtils utils = new AddressUtils() {
+            @Override protected void nop() {
+                // NOTE : this is put in because Google puts a threshold on # of API requests you can make.
+                try {
+                    Thread.sleep(500);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+            }
+        };
+        GeocodeResponse geocode = utils.getGeocode("6 saskatoon drive");
+        boolean same = false;
+        assertTrue(utils.compare("6 sskatoon, Toronto", "  6 SASKatoon drive, Etobicoke"));
+        assertTrue(utils.compare("6 sskatoon, Toronto", "  6 SASKatoon drive, Etobicoke"));
+        assertFalse(utils.compareWithThreshold("m9p2e7, Toronto", "  6 SASKatoon drive, Etobicoke", .00001));
+        assertTrue(utils.compareWithThreshold("m9p-2e7, Toronto", "  6 SASKatoon drive, Canada", .5));
+        assertTrue(utils.compare("6 saskatoon, Toronto", "  6 SASKatoon drive, Etobicoke"));
+        assertTrue(utils.compare("6 saskatoon, m9p 2e7", "    6Saskatoon Dr"));
+        assertTrue(utils.compare("6 siskatoon, Toronto", "  6 SASKatoon drive, Etobicoke"));
+        assertTrue(utils.compare("6 sskatoon, Toronto", "  6 SASKatoon drive, Etobicoke"));
+        assertTrue(utils.compare("6 sskatoon, Toronto", "  6 SASKatoon drive, Etobicoke"));
+        assertTrue(utils.compare("6 saskatoon DR. m9p   2E7", " 6 SASKATOON DRIVE, CANADA"));
+    }
+
+}
Index: src/main/java/demo/TokenMgrError.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/TokenMgrError.java	(revision )
+++ src/main/java/demo/TokenMgrError.java	(revision )
@@ -0,0 +1,147 @@
+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 5.0 */
+/* JavaCCOptions: */
+package demo;
+
+/** Token Manager Error. */
+public class TokenMgrError extends Error
+{
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /*
+   * Ordinals for various reasons why an Error of this type can be thrown.
+   */
+
+  /**
+   * Lexical error occurred.
+   */
+  static final int LEXICAL_ERROR = 0;
+
+  /**
+   * An attempt was made to create a second instance of a static token manager.
+   */
+  static final int STATIC_LEXER_ERROR = 1;
+
+  /**
+   * Tried to change to an invalid lexical state.
+   */
+  static final int INVALID_LEXICAL_STATE = 2;
+
+  /**
+   * Detected (and bailed out of) an infinite loop in the token manager.
+   */
+  static final int LOOP_DETECTED = 3;
+
+  /**
+   * Indicates the reason why the exception is thrown. It will have
+   * one of the above 4 values.
+   */
+  int errorCode;
+
+  /**
+   * Replaces unprintable characters by their escaped (or unicode escaped)
+   * equivalents in the given string
+   */
+  protected static final String addEscapes(String str) {
+    StringBuffer retval = new StringBuffer();
+    char ch;
+    for (int i = 0; i < str.length(); i++) {
+      switch (str.charAt(i))
+      {
+        case 0 :
+          continue;
+        case '\b':
+          retval.append("\\b");
+          continue;
+        case '\t':
+          retval.append("\\t");
+          continue;
+        case '\n':
+          retval.append("\\n");
+          continue;
+        case '\f':
+          retval.append("\\f");
+          continue;
+        case '\r':
+          retval.append("\\r");
+          continue;
+        case '\"':
+          retval.append("\\\"");
+          continue;
+        case '\'':
+          retval.append("\\\'");
+          continue;
+        case '\\':
+          retval.append("\\\\");
+          continue;
+        default:
+          if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+            String s = "0000" + Integer.toString(ch, 16);
+            retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+          } else {
+            retval.append(ch);
+          }
+          continue;
+      }
+    }
+    return retval.toString();
+  }
+
+  /**
+   * Returns a detailed message for the Error when it is thrown by the
+   * token manager to indicate a lexical error.
+   * Parameters :
+   *    EOFSeen     : indicates if EOF caused the lexical error
+   *    curLexState : lexical state in which this error occurred
+   *    errorLine   : line number when the error occurred
+   *    errorColumn : column number when the error occurred
+   *    errorAfter  : prefix that was seen before this error occurred
+   *    curchar     : the offending character
+   * Note: You can customize the lexical error message by modifying this method.
+   */
+  protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
+    return("Lexical error at line " +
+          errorLine + ", column " +
+          errorColumn + ".  Encountered: " +
+          (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
+          "after : \"" + addEscapes(errorAfter) + "\"");
+  }
+
+  /**
+   * You can also modify the body of this method to customize your error messages.
+   * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
+   * of end-users concern, so you can return something like :
+   *
+   *     "Internal Error : Please file a bug report .... "
+   *
+   * from this method for such cases in the release version of your parser.
+   */
+  public String getMessage() {
+    return super.getMessage();
+  }
+
+  /*
+   * Constructors of various flavors follow.
+   */
+
+  /** No arg constructor. */
+  public TokenMgrError() {
+  }
+
+  /** Constructor with message and reason. */
+  public TokenMgrError(String message, int reason) {
+    super(message);
+    errorCode = reason;
+  }
+
+  /** Full Constructor. */
+  public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
+    this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
+  }
+}
+/* JavaCC - OriginalChecksum=fcfdeee33b1366c1859bf802dec86e8e (do not edit this line) */
Index: src/main/java/demo/EasyTabbedPanel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/EasyTabbedPanel.java	(revision )
+++ src/main/java/demo/EasyTabbedPanel.java	(revision )
@@ -0,0 +1,234 @@
+package demo;
+
+
+import com.google.common.collect.Lists;
+import com.google.gson.Gson;
+import org.apache.wicket.Application;
+import org.apache.wicket.Component;
+import org.apache.wicket.ajax.AjaxRequestTarget;
+import org.apache.wicket.ajax.markup.html.AjaxLink;
+import org.apache.wicket.ajax.markup.html.form.AjaxButton;
+import org.apache.wicket.markup.head.*;
+import org.apache.wicket.markup.html.WebMarkupContainer;
+import org.apache.wicket.markup.html.basic.Label;
+import org.apache.wicket.markup.html.form.Form;
+import org.apache.wicket.markup.html.list.Loop;
+import org.apache.wicket.markup.html.list.LoopItem;
+import org.apache.wicket.markup.html.panel.Panel;
+import org.apache.wicket.model.AbstractReadOnlyModel;
+import org.apache.wicket.model.IModel;
+import org.apache.wicket.model.Model;
+import org.apache.wicket.request.resource.CssResourceReference;
+import org.apache.wicket.request.resource.JavaScriptResourceReference;
+
+import java.io.Serializable;
+import java.util.List;
+
+
+public abstract class EasyTabbedPanel<T extends Tab<?>> extends Panel {
+
+    private static final String TAB_PANEL_ID = "panel";
+    private static final String SELECT_LAST_TAB_JS = "$('#%s').tabPanel.selectLastTab()";
+    private static final String BLANK_SLATE_ID = "blankSlate";
+    private static final String TAB_PANEL_INIT = "easy.tabPanel.init(%s)";
+
+    private final JavaScriptHeaderItem TAB_PANEL_JS = JavaScriptReferenceHeaderItem.forReference(new JavaScriptResourceReference(EasyTabbedPanel.class, "easyTabbedPanel.js"));
+    private final CssHeaderItem TAB_PANEL_CSS = CssHeaderItem.forReference(new CssResourceReference(EasyTabbedPanel.class,"easyTabbedPanel.css"));
+
+    private T currentTab = null;
+    private Model<String> header;
+    private List<T> tabs;
+    private boolean mandatory;
+
+    public EasyTabbedPanel(final String id, final List<T> data, Model<String> header) {
+        super(id);
+        setOutputMarkupId(true);
+        this.header = header;
+        this.tabs = data;
+        currentTab = tabs.size()==0 ? null: tabs.get(0);
+    }
+
+    private WebMarkupContainer createBlankSlate(String id) {
+        return new WebMarkupContainer(id);
+    }
+
+    @Override
+    protected void onInitialize() {
+        super.onInitialize();
+        final IModel<Integer> tabCount = new AbstractReadOnlyModel<Integer>() {
+            @Override public Integer getObject() {
+                return EasyTabbedPanel.this.tabs.size();
+            }
+        };
+
+
+        Form form = new Form("form");
+        add(form);
+
+        WebMarkupContainer tabsContainer;
+        form.add(tabsContainer = new WebMarkupContainer("tabsContainer"));
+
+        tabsContainer.add(new Label("header", getHeaderModel()));
+        tabsContainer.add(new AjaxButton("add") {
+            @Override protected void onSubmit(AjaxRequestTarget target, Form<?> form) {
+                super.onSubmit(target,form);
+                addTab(target);
+            }
+        });
+
+        tabsContainer.add(new Loop("tabs", tabCount) {
+            @Override protected void populateItem(final LoopItem item) {
+                final int index = item.getIndex();
+                final Tab tab = EasyTabbedPanel.this.tabs.get(index);
+                final WebMarkupContainer titleLink = new WebMarkupContainer("link");
+                titleLink.add(newTitle("title", tab.getTitle(), index));
+                item.add(titleLink);
+                item.add(newDeleteButton("delete", item.getIndex()));
+            }
+
+            @Override
+            protected LoopItem newItem(final int iteration) {
+                return newTabContainer(iteration);
+            }
+        });
+
+        WebMarkupContainer panelContainer = new WebMarkupContainer("panelContainer");
+        form.add(panelContainer);
+
+        panelContainer.add(new Loop("panels", tabCount) {
+            @Override protected void populateItem(final LoopItem item) {
+                final int index = item.getIndex();
+                final Tab tab = EasyTabbedPanel.this.tabs.get(index);
+                item.add(tab.createPanel(TAB_PANEL_ID));
+                item.setRenderBodyOnly(true);
+            }
+
+            @Override
+            protected LoopItem newItem(final int iteration) {
+                return newTabContainer(iteration);
+            }
+        });
+
+        panelContainer.add(createBlankSlate(BLANK_SLATE_ID));
+    }
+
+    protected void addTab(AjaxRequestTarget target) {
+        tabs.add(currentTab = createNewTab());
+//        target.appendJavaScript(String.format(SELECT_LAST_TAB_JS, getOutputMarkupId()));
+        target.add(EasyTabbedPanel.this);
+    }
+
+    protected abstract T createNewTab();
+
+    private Component newDeleteButton(String id, final int index) {
+        return new AjaxLink(id) {
+            @Override public boolean isVisible() {
+                return tabs.size()>1 || !isMandatory();   // if tab is last one and it's a mandatory field then don't show this button.  e.g. can't delete only driver. (but you can delete only conviction).
+            }
+            @Override public void onClick(AjaxRequestTarget target) {
+                deleteTab(target, index);
+                target.add(EasyTabbedPanel.this);
+            }
+        };
+    }
+
+    protected void deleteTab(AjaxRequestTarget target, int index) {
+        tabs.remove(tabs.get(index));
+        currentTab = tabs.size()==0 ? null : tabs.get(Math.min(index, tabs.size() - 1));
+    }
+
+    private T getCurrentTab() {
+        return currentTab;
+    }
+
+    protected boolean isMandatory() {
+        return mandatory;
+    }
+
+    @Override
+    protected IModel<?> initModel() {
+        return new Model<Integer>(-1);
+    }
+
+    protected LoopItem newTabContainer(final int index) {
+        return new LoopItem(index);
+    }
+
+    @Override
+    protected void onBeforeRender() {
+        super.onBeforeRender();
+    }
+
+    @Override
+    public void renderHead(IHeaderResponse response) {
+        super.renderHead(response);
+        response.render(TAB_PANEL_JS);
+        response.render(TAB_PANEL_CSS);
+        response.render(OnDomReadyHeaderItem.forScript(String.format(TAB_PANEL_INIT, new Gson().toJson(getOptions()))));
+        response.render(JavaScriptHeaderItem.forReference(Application.get().getJavaScriptLibrarySettings().getJQueryReference()));
+    }
+
+    protected EasyTabbedPanelOptions getOptions() {
+        return new EasyTabbedPanelOptions();
+    }
+
+    protected Component newTitle(final String titleId, final String title, final int index) {
+        return new Label(titleId, title);
+    }
+
+    protected WebMarkupContainer newTabLink(final String linkId, final int index) {
+        return new AjaxLink<Void>(linkId) {
+            @Override public void onClick(AjaxRequestTarget target) {
+                target.add(EasyTabbedPanel.this);
+            }
+        };
+    }
+
+    public IModel<String> getHeaderModel() {
+        return new Model<String>() {
+            @Override public String getObject() {
+                int tabCount = tabs.size();
+                return String.format("%s%s",header.getObject(),(tabCount>1 ? " ("+tabCount+")" : ""));
+            }
+        };
+    }
+
+    public <X extends EasyTabbedPanel> X withAtLeastOne() {
+        mandatory = true;
+        return (X) this;
+    }
+
+    public <X extends EasyTabbedPanel> X withZeroOrMore() {
+        mandatory = false;
+        return (X) this;
+    }
+
+
+    // ---------------------------------------------------------------
+
+    public class EasyTabbedPanelOptions implements Serializable {
+        // TODO : refactor this into generic json options object (map).
+        public String id = EasyTabbedPanel.this.getMarkupId();
+        public Boolean mandatory = isMandatory();
+        public List<String> titleInputs;
+        public Boolean collapsed;
+        public String minTabSize = "150px";
+        public Boolean tooltipOnAdd;
+        public int current = tabs.indexOf(getCurrentTab());
+        public HeaderOptions header = new HeaderOptions();
+
+
+        public EasyTabbedPanelOptions() {
+            titleInputs = Lists.newArrayList();
+            for (T tab:tabs) {
+                titleInputs.add(tab.getTitleInput());
+            }
+        }
+    }
+
+    public class HeaderOptions implements Serializable {
+        public String minWidth = "7em";
+        public String maxWidth = "10em";
+    }
+
+}
Index: src/main/java/demo/name.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/name.js	(revision )
+++ src/main/java/demo/name.js	(revision )
@@ -0,0 +1,119 @@
+
+var easy = easy ? easy : {};
+
+easy.name = (function() {
+
+    var names = [];
+
+    var create = function(options) {
+        var widget = name(options);
+        widget.init();
+        return $('#'+options.id).data('nameWidget',widget);
+    }
+
+    function unquoted(text) {
+        if (!text) return '';
+        return text.replace(/"/g, "");
+    }
+
+    function quoted(input) {
+        if (!input.value) return '';
+        var text = input.value.trim();
+        text = text.indexOf(' ')!=-1 ? '"' + text + '"' : text;
+        if (text.length>0) text = text + ' ';
+        return text;
+    }
+
+    function name(opts) {
+        var defaults = {popover:{html:true,placement:'auto right',trigger:'manual',title:'Did you mean...?'}};
+        var options = $.extend(defaults, opts);
+        var $name = $('#'+opts.id);
+        var $dialog;
+        var $parentForm = $name.closest('form');
+
+        function popover() {
+            return $name.next('.popover');
+        }
+
+        function updateFromDialog(nameInputs) {
+            $name.val(quoted(nameInputs[0]) + quoted(nameInputs[1]) + quoted(nameInputs[2]));
+        }
+
+        function didYouMean(name) {
+            $name.popover('show');
+            var nameInputs = popover().find('.popover-content input');
+            nameInputs[0].value = unquoted(name.first);
+            nameInputs[1].value = unquoted(name.middle);
+            nameInputs[2].value = unquoted(name.last);
+            updateFromDialog(nameInputs);
+            nameInputs.keyup(function() {
+                setTimeout(function() { updateFromDialog(nameInputs); }, 50 );  // keep polling when input text might change.
+            });
+        }
+
+        function update() {
+            var formattedText = [];
+            $dialog.find('input').each(function() {
+                var text = $(this).val().toString().trim();
+                if (text.split(" ").length>1 && text.toString().substring(0, 1)!=='"') {
+                    formattedText.push('"' + text.replace('"','').trim() + '"');
+                } else {
+                    formattedText.push(text.replace('"','').trim());
+                }
+            });
+            $name.val(formattedText.join(' '));
+        }
+
+        function validateByAjax() {
+            var url = options.callback + "&text="+$name.val();
+            Wicket.Ajax.get({ u: url });
+        }
+
+        var init = function() {
+            $name.blur(function(e) {
+                validateByAjax();
+            });
+            $name.popover({
+                html : true,
+                placement : 'auto left',
+                trigger : 'manual',
+                title: 'Did you mean...',
+                // TODO : refactor this so it is part of EasyName.html.  make it a fragment with customizable labels/title.
+                content: '<form class="did-you-mean"><label>First</label><input type="text"/><label>Middle</label><input type="text"/><label>Last</label><input type="text"/><a>Ok</a></form>'
+            });
+            names.push(this);
+            if (names.length==1) {   // first time thru add listener, only need to do it once.
+                $('body').on('click', function (e) {
+                    var popover = $(e.target).parents('.popover');
+                    $.each(names,function(index,value) {
+                        value.maybeHidePopover(popover);
+                    });
+                });
+            }
+        };
+
+        var maybeHidePopover = function(clickedPopover) {
+            var myPopover = $name.next('.popover');
+            if(clickedPopover.length>0 && myPopover.length>0 & clickedPopover[0]===myPopover[0]) {
+                // don't hide unless we know it's not the one we are associated with.
+            } else {
+                $name.popover('hide');
+            }
+        };
+
+        return {
+            init : init,
+            maybeHidePopover : maybeHidePopover,
+            didYouMean : didYouMean
+        };
+    }
+
+    return {
+        create: create
+    };
+
+})();
+
+
+
+
Index: EasyLibrary/src/test/java/com/brovada/easy/widgets/DateParserTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- EasyLibrary/src/test/java/com/brovada/easy/widgets/DateParserTest.java	(revision )
+++ EasyLibrary/src/test/java/com/brovada/easy/widgets/DateParserTest.java	(revision )
@@ -0,0 +1,89 @@
+package com.brovada.easy.widgets;
+
+import junit.framework.TestCase;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+
+public class DateParserTest  extends TestCase {
+
+    @Test
+    public void test_dateParser() throws ParseException {
+        DateParser parser = new DateParser(new ByteArrayInputStream("".getBytes()));
+        ParsedDate date = parser.parseDate("30 weeks");
+        System.out.println(date);
+        date = parser.parseDate("2001-10-08");
+        System.out.println(date);
+        date = parser.parseDate("feb 11 '19...feb 17");
+        System.out.println(date);
+        date = parser.parseDate("feb 1 2014 ... feb 17");
+        System.out.println(date);
+        date = parser.parseDate("next year");
+        System.out.println(date);
+        date = parser.parseDate("july 4 to next year");
+        System.out.println(date);
+        date = parser.parseDate("2001\\10\\08");
+        System.out.println(date);
+        date = parser.parseDate("last week for 2 week");
+        System.out.println(date);
+        date = parser.parseDate("this week for 1 month");
+        System.out.println(date);
+        date = parser.parseDate("next week for a year");
+        System.out.println(date);
+        date = parser.parseDate("yesterday for 6 YRS");
+        System.out.println(date);
+        date = parser.parseDate("today 1 YrS");
+        System.out.println(date);
+        date = parser.parseDate("yesterday tomorrow");
+        System.out.println(date);
+        date = parser.parseDate("july 17 for one quarter");
+        System.out.println(date);
+        date = parser.parseDate("july 14...last month");
+        System.out.println(date);
+        date = parser.parseDate("july 4 to next year");
+        System.out.println(date);
+        date = parser.parseDate("april 7- next wk");
+        System.out.println(date);
+        date = parser.parseDate("FEB 30 to FEB 14,1999");
+        System.out.println(date);
+        date = parser.parseDate("today");
+        System.out.println(date);
+        date = parser.parseDate("tomorrow");
+        System.out.println(date);
+        date = parser.parseDate("next week");
+        System.out.println(date);
+        date = parser.parseDate("feb 11 14..next week");
+        System.out.println(date);
+        date = parser.parseDate("feb 11 14..last week");
+        System.out.println(date);
+        date = parser.parseDate("feb 11 14 for 2 years");
+        System.out.println(date);
+        date = parser.parseDate("jan 1 99");
+        System.out.println(date);
+        date = parser.parseDate("feb 21 '99");
+        System.out.println(date);
+        date = parser.parseDate("feb 21 '99 to feb 22, 2055");
+        System.out.println(date);
+        date = parser.parseDate("feb 11 14...feb 17");
+        System.out.println(date);
+        date = parser.parseDate("01/11/99");
+        System.out.println(date);
+        date = parser.parseDate("15/04/2011");
+        System.out.println(date);
+        date = parser.parseDate("15\\04\\2011");
+        System.out.println(date);
+        date = parser.parseDate("15-04-2011");
+        System.out.println(date);
+        date = parser.parseDate("feb 11 14..feb 17");
+        System.out.println(date);
+        date = parser.parseDate("7 days");
+        System.out.println(date);
+        date = parser.parseDate("1 weeks");
+        System.out.println(date);
+        date = parser.parseDate("today for 43 months");
+        System.out.println(date);
+        date = parser.parseDate("1 WK");
+        System.out.println(date);
+    }
+
+}
Index: src/main/java/demo/Tab.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/Tab.java	(revision )
+++ src/main/java/demo/Tab.java	(revision )
@@ -0,0 +1,45 @@
+package demo;
+
+
+import org.apache.wicket.Component;
+import org.apache.wicket.ajax.form.AjaxFormValidatingBehavior;
+import org.apache.wicket.markup.html.WebMarkupContainer;
+import org.apache.wicket.markup.html.form.Form;
+import org.apache.wicket.markup.html.form.FormComponent;
+import org.apache.wicket.markup.html.form.TextField;
+import org.apache.wicket.model.IModel;
+import org.apache.wicket.model.Model;
+import org.apache.wicket.util.visit.IVisit;
+import org.apache.wicket.util.visit.IVisitor;
+
+import javax.swing.text.html.FormSubmitEvent;
+import java.io.Serializable;
+
+public abstract class Tab<T extends Serializable> implements Serializable {
+
+    protected IModel<T> model;
+    protected WebMarkupContainer panel;
+    private transient boolean current = false;
+    private String panelId;
+    private String titleInput;
+
+    public Tab(T value) {
+        this.model = Model.of(value);
+    }
+
+    public String getTitle() {
+        // not null safe. typically you will implement this yourself.
+        return model.getObject().toString();
+    }
+
+    protected Component setTitleInput(FormComponent input) {
+        titleInput = "#"+input.setOutputMarkupId(true).getMarkupId();  // set the jquery selector of this component.
+        return input;
+    }
+
+    protected abstract WebMarkupContainer createPanel(String id);
+
+    public String getTitleInput() {
+        return titleInput;
+    }
+}
Index: src/test/java/demo/TestHomePage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/java/demo/TestHomePage.java	(revision )
+++ src/test/java/demo/TestHomePage.java	(revision )
@@ -0,0 +1,29 @@
+package demo;
+
+import junit.framework.TestCase;
+import org.apache.wicket.util.tester.WicketTester;
+
+/**
+ * Simple test using the WicketTester
+ */
+public class TestHomePage extends TestCase
+{
+	private WicketTester tester;
+
+	public void setUp()
+	{
+		tester = new WicketTester();
+	}
+
+	public void testRenderMyPage()
+	{
+		//start and render the test page
+		tester.startPage(HomePage.class);
+
+		//assert rendered page class
+		tester.assertRenderedPage(HomePage.class);
+
+		//assert rendered label component
+		tester.assertLabel("message", "If you see this message wicket is properly configured and running");
+	}
+}
Index: src/main/java/demo/NameParserConstants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/NameParserConstants.java	(revision )
+++ src/main/java/demo/NameParserConstants.java	(revision )
@@ -0,0 +1,65 @@
+/* Generated By:JavaCC: Do not edit this line. NameParserConstants.java */
+package demo;
+
+
+/**
+ * Token literal values and constants.
+ * Generated by org.javacc.parser.OtherFilesGen#start()
+ */
+public interface NameParserConstants {
+
+  /** End of File. */
+  int EOF = 0;
+  /** RegularExpression Id. */
+  int AND = 5;
+  /** RegularExpression Id. */
+  int MR = 6;
+  /** RegularExpression Id. */
+  int MRS = 7;
+  /** RegularExpression Id. */
+  int MISS = 8;
+  /** RegularExpression Id. */
+  int MADAM = 9;
+  /** RegularExpression Id. */
+  int SIR = 10;
+  /** RegularExpression Id. */
+  int MS = 11;
+  /** RegularExpression Id. */
+  int DOCTOR = 12;
+  /** RegularExpression Id. */
+  int ROMAN_NUMERALS = 13;
+  /** RegularExpression Id. */
+  int SENIOR = 14;
+  /** RegularExpression Id. */
+  int JUNIOR = 15;
+  /** RegularExpression Id. */
+  int NICK_NAME = 16;
+  /** RegularExpression Id. */
+  int NAME = 17;
+
+  /** Lexical state. */
+  int DEFAULT = 0;
+
+  /** Literal token values. */
+  String[] tokenImage = {
+    "<EOF>",
+    "\" \"",
+    "\"\\t\"",
+    "\"\\r\"",
+    "\"\\n\"",
+    "<AND>",
+    "<MR>",
+    "<MRS>",
+    "\"miss\"",
+    "<MADAM>",
+    "\"sir\"",
+    "<MS>",
+    "<DOCTOR>",
+    "<ROMAN_NUMERALS>",
+    "<SENIOR>",
+    "<JUNIOR>",
+    "<NICK_NAME>",
+    "<NAME>",
+  };
+
+}
Index: src/main/java/demo/NameParserTokenManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/NameParserTokenManager.java	(revision )
+++ src/main/java/demo/NameParserTokenManager.java	(revision )
@@ -0,0 +1,994 @@
+/* Generated By:JavaCC: Do not edit this line. NameParserTokenManager.java */
+package demo;
+import java.io.*;
+import java.util.*;
+import demo.Name;
+
+/** Token Manager. */
+public class NameParserTokenManager implements NameParserConstants
+{
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_0(int pos, long active0)
+{
+      debugStream.println("   No more string literal token matches are possible.");
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x100L) != 0L)
+         {
+            jjmatchedKind = 13;
+            return 40;
+         }
+         if ((active0 & 0x400L) != 0L)
+         {
+            jjmatchedKind = 17;
+            return 20;
+         }
+         return -1;
+      case 1:
+         if ((active0 & 0x400L) != 0L)
+         {
+            jjmatchedKind = 17;
+            jjmatchedPos = 1;
+            return 10;
+         }
+         if ((active0 & 0x100L) != 0L)
+         {
+            jjmatchedKind = 13;
+            jjmatchedPos = 1;
+            return 39;
+         }
+         return -1;
+      case 2:
+         if ((active0 & 0x400L) != 0L)
+            return 10;
+         if ((active0 & 0x100L) != 0L)
+         {
+            jjmatchedKind = 17;
+            jjmatchedPos = 2;
+            return 38;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_0(int pos, long active0)
+{
+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   debugStream.println("   No more string literal token matches are possible.");
+   debugStream.println("   Currently matched the first " + (jjmatchedPos + 1) + " characters as a " + tokenImage[jjmatchedKind] + " token.");
+   return pos + 1;
+}
+private int jjMoveStringLiteralDfa0_0()
+{
+   switch(curChar)
+   {
+      case 77:
+      case 109:
+         return jjMoveStringLiteralDfa1_0(0x100L);
+      case 83:
+      case 115:
+         return jjMoveStringLiteralDfa1_0(0x400L);
+      default :
+      debugStream.println("   No string literal matches possible.");
+         return jjMoveNfa_0(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_0(long active0)
+{
+   if (jjmatchedKind != 0 && jjmatchedKind != 0x7fffffff)
+      debugStream.println("   Currently matched the first " + (jjmatchedPos + 1) + " characters as a " + tokenImage[jjmatchedKind] + " token.");
+   debugStream.println("   Possible string literal matches : { "
+ +
+         jjKindsForBitVector(0, active0)  + " } ");
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(0, active0);
+      if (jjmatchedKind != 0 && jjmatchedKind != 0x7fffffff)
+         debugStream.println("   Currently matched the first " + (jjmatchedPos + 1) + " characters as a " + tokenImage[jjmatchedKind] + " token.");
+      return 1;
+   }
+   debugStream.println("Current character : " + TokenMgrError.addEscapes(String.valueOf(curChar)) + " (" + (int)curChar + ") at line " + input_stream.getEndLine() + " column " + input_stream.getEndColumn());
+   switch(curChar)
+   {
+      case 73:
+      case 105:
+         return jjMoveStringLiteralDfa2_0(active0, 0x500L);
+      default :
+      debugStream.println("   No string literal matches possible.");
+         break;
+   }
+   return jjStartNfa_0(0, active0);
+}
+private int jjMoveStringLiteralDfa2_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(0, old0);
+   if (jjmatchedKind != 0 && jjmatchedKind != 0x7fffffff)
+      debugStream.println("   Currently matched the first " + (jjmatchedPos + 1) + " characters as a " + tokenImage[jjmatchedKind] + " token.");
+   debugStream.println("   Possible string literal matches : { "
+ +
+         jjKindsForBitVector(0, active0)  + " } ");
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(1, active0);
+      if (jjmatchedKind != 0 && jjmatchedKind != 0x7fffffff)
+         debugStream.println("   Currently matched the first " + (jjmatchedPos + 1) + " characters as a " + tokenImage[jjmatchedKind] + " token.");
+      return 2;
+   }
+   debugStream.println("Current character : " + TokenMgrError.addEscapes(String.valueOf(curChar)) + " (" + (int)curChar + ") at line " + input_stream.getEndLine() + " column " + input_stream.getEndColumn());
+   switch(curChar)
+   {
+      case 82:
+      case 114:
+         if ((active0 & 0x400L) != 0L)
+            return jjStartNfaWithStates_0(2, 10, 10);
+         break;
+      case 83:
+      case 115:
+         return jjMoveStringLiteralDfa3_0(active0, 0x100L);
+      default :
+      debugStream.println("   No string literal matches possible.");
+         break;
+   }
+   return jjStartNfa_0(1, active0);
+}
+private int jjMoveStringLiteralDfa3_0(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(1, old0);
+   if (jjmatchedKind != 0 && jjmatchedKind != 0x7fffffff)
+      debugStream.println("   Currently matched the first " + (jjmatchedPos + 1) + " characters as a " + tokenImage[jjmatchedKind] + " token.");
+   debugStream.println("   Possible string literal matches : { "
+ +
+         jjKindsForBitVector(0, active0)  + " } ");
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(2, active0);
+      if (jjmatchedKind != 0 && jjmatchedKind != 0x7fffffff)
+         debugStream.println("   Currently matched the first " + (jjmatchedPos + 1) + " characters as a " + tokenImage[jjmatchedKind] + " token.");
+      return 3;
+   }
+   debugStream.println("Current character : " + TokenMgrError.addEscapes(String.valueOf(curChar)) + " (" + (int)curChar + ") at line " + input_stream.getEndLine() + " column " + input_stream.getEndColumn());
+   switch(curChar)
+   {
+      case 83:
+      case 115:
+         if ((active0 & 0x100L) != 0L)
+            return jjStartNfaWithStates_0(3, 8, 44);
+         break;
+      default :
+      debugStream.println("   No string literal matches possible.");
+         break;
+   }
+   return jjStartNfa_0(2, active0);
+}
+private int jjStartNfaWithStates_0(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   debugStream.println("   No more string literal token matches are possible.");
+   debugStream.println("   Currently matched the first " + (jjmatchedPos + 1) + " characters as a " + tokenImage[jjmatchedKind] + " token.");
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   debugStream.println("Current character : " + TokenMgrError.addEscapes(String.valueOf(curChar)) + " (" + (int)curChar + ") at line " + input_stream.getEndLine() + " column " + input_stream.getEndColumn());
+   return jjMoveNfa_0(state, pos + 1);
+}
+static final long[] jjbitVec0 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 60;
+   int i = 1;
+   jjstateSet[0] = startState;
+      debugStream.println("   Starting NFA to match one of : " + jjKindsForStateVector(curLexState, jjstateSet, 0, 1));
+      debugStream.println("Current character : " + TokenMgrError.addEscapes(String.valueOf(curChar)) + " (" + (int)curChar + ") at line " + input_stream.getEndLine() + " column " + input_stream.getEndColumn());
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 40:
+               case 10:
+                  if ((0x608000000000L & l) == 0L)
+                     break;
+                  if (kind > 17)
+                     kind = 17;
+                  jjCheckNAdd(10);
+                  break;
+               case 0:
+                  if ((0x608000000000L & l) != 0L)
+                  {
+                     if (kind > 17)
+                        kind = 17;
+                     jjCheckNAdd(10);
+                  }
+                  else if ((0x84000000000L & l) != 0L)
+                  {
+                     if (kind > 5)
+                        kind = 5;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAdd(8);
+                  if (curChar == 39)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 44:
+                  if ((0x608000000000L & l) == 0L)
+                     break;
+                  if (kind > 17)
+                     kind = 17;
+                  jjCheckNAdd(10);
+                  break;
+               case 39:
+                  if ((0x608000000000L & l) == 0L)
+                     break;
+                  if (kind > 17)
+                     kind = 17;
+                  jjCheckNAdd(10);
+                  break;
+               case 38:
+                  if ((0x608000000000L & l) == 0L)
+                     break;
+                  if (kind > 17)
+                     kind = 17;
+                  jjCheckNAdd(10);
+                  break;
+               case 20:
+                  if ((0x608000000000L & l) == 0L)
+                     break;
+                  if (kind > 17)
+                     kind = 17;
+                  jjCheckNAdd(10);
+                  break;
+               case 2:
+                  if (curChar == 39)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 7:
+                  if (curChar == 34)
+                     jjCheckNAdd(8);
+                  break;
+               case 8:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddTwoStates(8, 9);
+                  break;
+               case 9:
+                  if (curChar == 34 && kind > 16)
+                     kind = 16;
+                  break;
+               case 13:
+                  if (curChar == 46 && kind > 15)
+                     kind = 15;
+                  break;
+               case 21:
+                  if (curChar == 46 && kind > 14)
+                     kind = 14;
+                  break;
+               case 34:
+                  if (curChar == 46 && kind > 12)
+                     kind = 12;
+                  break;
+               case 42:
+                  if (curChar == 46 && kind > 6)
+                     kind = 6;
+                  break;
+               case 49:
+                  if (curChar == 46 && kind > 7)
+                     kind = 7;
+                  break;
+               case 59:
+                  if (curChar == 46 && kind > 11)
+                     kind = 11;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 40:
+                  if ((0x7fffffe07fffffeL & l) != 0L)
+                  {
+                     if (kind > 17)
+                        kind = 17;
+                     jjCheckNAdd(10);
+                  }
+                  if ((0x140321801403218L & l) != 0L)
+                  {
+                     if (kind > 13)
+                        kind = 13;
+                     jjCheckNAdd(6);
+                  }
+                  else if ((0x8000000080000L & l) != 0L)
+                  {
+                     if (kind > 11)
+                        kind = 11;
+                     jjstateSet[jjnewStateCnt++] = 59;
+                  }
+                  else if ((0x200000002L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 55;
+                  else if ((0x4000000040000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 48;
+                  if ((0x200000002000L & l) != 0L)
+                  {
+                     if (kind > 9)
+                        kind = 9;
+                  }
+                  else if ((0x1000000010L & l) != 0L)
+                     jjCheckNAdd(51);
+                  else if ((0x200000002L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 53;
+                  else if ((0x20000000200L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 46;
+                  else if ((0x4000000040000L & l) != 0L)
+                  {
+                     if (kind > 6)
+                        kind = 6;
+                     jjstateSet[jjnewStateCnt++] = 42;
+                  }
+                  if ((0x20000000200L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 39;
+                  break;
+               case 0:
+                  if ((0x7fffffe07fffffeL & l) != 0L)
+                  {
+                     if (kind > 17)
+                        kind = 17;
+                     jjCheckNAdd(10);
+                  }
+                  if ((0x140321801403218L & l) != 0L)
+                  {
+                     if (kind > 13)
+                        kind = 13;
+                     jjCheckNAdd(6);
+                  }
+                  else if ((0x8000000080000L & l) != 0L)
+                     jjAddStates(0, 1);
+                  else if ((0x40000000400L & l) != 0L)
+                     jjAddStates(2, 3);
+                  else if ((0x200000002L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  if ((0x200000002000L & l) != 0L)
+                     jjCheckNAddStates(4, 12);
+                  else if ((0x1000000010L & l) != 0L)
+                     jjAddStates(13, 14);
+                  break;
+               case 44:
+                  if ((0x7fffffe07fffffeL & l) != 0L)
+                  {
+                     if (kind > 17)
+                        kind = 17;
+                     jjCheckNAdd(10);
+                  }
+                  if ((0x2000000020L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 43;
+                  break;
+               case 39:
+                  if ((0x7fffffe07fffffeL & l) != 0L)
+                  {
+                     if (kind > 17)
+                        kind = 17;
+                     jjCheckNAdd(10);
+                  }
+                  if ((0x140321801403218L & l) != 0L)
+                  {
+                     if (kind > 13)
+                        kind = 13;
+                     jjCheckNAdd(6);
+                  }
+                  else if ((0x8000000080000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 45;
+                  if ((0x8000000080000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 38;
+                  break;
+               case 38:
+                  if ((0x7fffffe07fffffeL & l) != 0L)
+                  {
+                     if (kind > 17)
+                        kind = 17;
+                     jjCheckNAdd(10);
+                  }
+                  if ((0x8000000080000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 44;
+                  else if ((0x10000000100000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 37;
+                  break;
+               case 20:
+                  if ((0x7fffffe07fffffeL & l) != 0L)
+                  {
+                     if (kind > 17)
+                        kind = 17;
+                     jjCheckNAdd(10);
+                  }
+                  if ((0x2000000020L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 25;
+                  else if ((0x4000000040000L & l) != 0L)
+                  {
+                     if (kind > 14)
+                        kind = 14;
+                     jjstateSet[jjnewStateCnt++] = 21;
+                  }
+                  break;
+               case 1:
+                  if ((0x400000004000L & l) != 0L && kind > 5)
+                     kind = 5;
+                  break;
+               case 3:
+                  if ((0x1000000010L & l) != 0L && kind > 5)
+                     kind = 5;
+                  break;
+               case 4:
+                  if ((0x400000004000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               case 5:
+                  if ((0x200000002L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 6:
+                  if ((0x140321801403218L & l) == 0L)
+                     break;
+                  if (kind > 13)
+                     kind = 13;
+                  jjCheckNAdd(6);
+                  break;
+               case 8:
+                  jjAddStates(15, 16);
+                  break;
+               case 10:
+                  if ((0x7fffffe07fffffeL & l) == 0L)
+                     break;
+                  if (kind > 17)
+                     kind = 17;
+                  jjCheckNAdd(10);
+                  break;
+               case 11:
+                  if ((0x40000000400L & l) != 0L)
+                     jjAddStates(2, 3);
+                  break;
+               case 12:
+                  if ((0x4000000040000L & l) == 0L)
+                     break;
+                  if (kind > 15)
+                     kind = 15;
+                  jjstateSet[jjnewStateCnt++] = 13;
+                  break;
+               case 14:
+                  if ((0x4000000040000L & l) != 0L && kind > 15)
+                     kind = 15;
+                  break;
+               case 15:
+                  if ((0x800000008000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 14;
+                  break;
+               case 16:
+                  if ((0x20000000200L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 15;
+                  break;
+               case 17:
+                  if ((0x400000004000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 16;
+                  break;
+               case 18:
+                  if ((0x20000000200000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 17;
+                  break;
+               case 19:
+                  if ((0x8000000080000L & l) != 0L)
+                     jjAddStates(0, 1);
+                  break;
+               case 22:
+                  if ((0x4000000040000L & l) != 0L && kind > 14)
+                     kind = 14;
+                  break;
+               case 23:
+                  if ((0x800000008000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 22;
+                  break;
+               case 24:
+                  if ((0x20000000200L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 23;
+                  break;
+               case 25:
+                  if ((0x400000004000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 24;
+                  break;
+               case 26:
+                  if ((0x2000000020L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 25;
+                  break;
+               case 27:
+                  if ((0x1000000010L & l) != 0L)
+                     jjAddStates(13, 14);
+                  break;
+               case 28:
+                  if ((0x4000000040000L & l) != 0L && kind > 12)
+                     kind = 12;
+                  break;
+               case 29:
+                  if ((0x800000008000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 28;
+                  break;
+               case 30:
+                  if ((0x10000000100000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 29;
+                  break;
+               case 31:
+                  if ((0x800000008L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 30;
+                  break;
+               case 32:
+                  if ((0x800000008000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 31;
+                  break;
+               case 33:
+                  if ((0x4000000040000L & l) == 0L)
+                     break;
+                  if (kind > 12)
+                     kind = 12;
+                  jjstateSet[jjnewStateCnt++] = 34;
+                  break;
+               case 35:
+                  if ((0x200000002000L & l) != 0L)
+                     jjCheckNAddStates(4, 12);
+                  break;
+               case 36:
+                  if ((0x4000000040000L & l) != 0L && kind > 6)
+                     kind = 6;
+                  break;
+               case 37:
+                  if ((0x2000000020L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 36;
+                  break;
+               case 41:
+                  if ((0x4000000040000L & l) == 0L)
+                     break;
+                  if (kind > 6)
+                     kind = 6;
+                  jjstateSet[jjnewStateCnt++] = 42;
+                  break;
+               case 43:
+                  if ((0x8000000080000L & l) != 0L && kind > 7)
+                     kind = 7;
+                  break;
+               case 45:
+                  if ((0x8000000080000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 44;
+                  break;
+               case 46:
+                  if ((0x8000000080000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 45;
+                  break;
+               case 47:
+                  if ((0x20000000200L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 46;
+                  break;
+               case 48:
+                  if ((0x8000000080000L & l) == 0L)
+                     break;
+                  if (kind > 7)
+                     kind = 7;
+                  jjstateSet[jjnewStateCnt++] = 49;
+                  break;
+               case 50:
+                  if ((0x4000000040000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 48;
+                  break;
+               case 51:
+                  if ((0x200000002000L & l) != 0L && kind > 9)
+                     kind = 9;
+                  break;
+               case 52:
+               case 55:
+                  if ((0x200000002L & l) != 0L)
+                     jjCheckNAdd(51);
+                  break;
+               case 53:
+                  if ((0x1000000010L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 52;
+                  break;
+               case 54:
+                  if ((0x200000002L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 53;
+                  break;
+               case 56:
+                  if ((0x200000002L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 55;
+                  break;
+               case 57:
+                  if ((0x1000000010L & l) != 0L)
+                     jjCheckNAdd(51);
+                  break;
+               case 58:
+                  if ((0x8000000080000L & l) == 0L)
+                     break;
+                  if (kind > 11)
+                     kind = 11;
+                  jjstateSet[jjnewStateCnt++] = 59;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 8:
+                  if ((jjbitVec0[i2] & l2) != 0L)
+                     jjAddStates(15, 16);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if (jjmatchedKind != 0 && jjmatchedKind != 0x7fffffff)
+         debugStream.println("   Currently matched the first " + (jjmatchedPos + 1) + " characters as a " + tokenImage[jjmatchedKind] + " token.");
+      if ((i = jjnewStateCnt) == (startsAt = 60 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      debugStream.println("   Possible kinds of longer matches : " + jjKindsForStateVector(curLexState, jjstateSet, startsAt, i));
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+      debugStream.println("Current character : " + TokenMgrError.addEscapes(String.valueOf(curChar)) + " (" + (int)curChar + ") at line " + input_stream.getEndLine() + " column " + input_stream.getEndColumn());
+   }
+}
+static final int[] jjnextStates = {
+   20, 26, 12, 18, 40, 41, 47, 50, 54, 56, 57, 51, 58, 32, 33, 8, 
+   9, 
+};
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, };
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "DEFAULT",
+};
+static final long[] jjtoToken = {
+   0x3ffe1L, 
+};
+static final long[] jjtoSkip = {
+   0x1eL, 
+};
+protected SimpleCharStream input_stream;
+private final int[] jjrounds = new int[60];
+private final int[] jjstateSet = new int[120];
+protected char curChar;
+/** Constructor. */
+public NameParserTokenManager(SimpleCharStream stream){
+   if (SimpleCharStream.staticFlag)
+      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
+   input_stream = stream;
+}
+
+/** Constructor. */
+public NameParserTokenManager(SimpleCharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+
+/** Reinitialise parser. */
+public void ReInit(SimpleCharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 60; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+
+/** Reinitialise parser. */
+public void ReInit(SimpleCharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+
+/** Switch to specified lex state. */
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 1 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   final Token t;
+   final String curTokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   curTokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, curTokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 0;
+int defaultLexState = 0;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {
+   try
+   {
+      curChar = input_stream.BeginToken();
+   }
+   catch(java.io.IOException e)
+   {
+      debugStream.println("Returning the <EOF> token.");
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      return matchedToken;
+   }
+
+   try { input_stream.backup(0);
+      while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L)
+   {
+      debugStream.println("Skipping character : " + TokenMgrError.addEscapes(String.valueOf(curChar)) + " (" + (int)curChar + ")");
+         curChar = input_stream.BeginToken();
+   }
+   }
+   catch (java.io.IOException e1) { continue EOFLoop; }
+   jjmatchedKind = 0x7fffffff;
+   jjmatchedPos = 0;
+      debugStream.println("Current character : " + TokenMgrError.addEscapes(String.valueOf(curChar)) + " (" + (int)curChar + ") at line " + input_stream.getEndLine() + " column " + input_stream.getEndColumn());
+   curPos = jjMoveStringLiteralDfa0_0();
+   if (jjmatchedKind != 0x7fffffff)
+   {
+      if (jjmatchedPos + 1 < curPos)
+      {
+         debugStream.println("   Putting back " + (curPos - jjmatchedPos - 1) + " characters into the input stream.");
+         input_stream.backup(curPos - jjmatchedPos - 1);
+      }
+    debugStream.println("****** FOUND A " + tokenImage[jjmatchedKind] + " MATCH (" + TokenMgrError.addEscapes(new String(input_stream.GetSuffix(jjmatchedPos + 1))) + ") ******\n");
+      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+      {
+         matchedToken = jjFillToken();
+         return matchedToken;
+      }
+      else
+      {
+         continue EOFLoop;
+      }
+   }
+   int error_line = input_stream.getEndLine();
+   int error_column = input_stream.getEndColumn();
+   String error_after = null;
+   boolean EOFSeen = false;
+   try { input_stream.readChar(); input_stream.backup(1); }
+   catch (java.io.IOException e1) {
+      EOFSeen = true;
+      error_after = curPos <= 1 ? "" : input_stream.GetImage();
+      if (curChar == '\n' || curChar == '\r') {
+         error_line++;
+         error_column = 0;
+      }
+      else
+         error_column++;
+   }
+   if (!EOFSeen) {
+      input_stream.backup(1);
+      error_after = curPos <= 1 ? "" : input_stream.GetImage();
+   }
+   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+  }
+}
+
+protected static final int[][][] statesForState = {
+ {
+   { 0, 2, 5, 6, 7, 10, 11, 19, 27, 35, },
+   { 1 },
+   { 0, 2, 5, 6, 7, 10, 11, 19, 27, 35, },
+   { 3 },
+   { 4 },
+   { 0, 2, 5, 6, 7, 10, 11, 19, 27, 35, },
+   { 39, 46, 6, 10, },
+   { 0, 2, 5, 6, 7, 10, 11, 19, 27, 35, },
+   { 8 },
+   { 9 },
+   { 44, 10, },
+   { 0, 2, 5, 6, 7, 10, 11, 19, 27, 35, },
+   { 12 },
+   { 13 },
+   { 14 },
+   { 15 },
+   { 16 },
+   { 17 },
+   { 18 },
+   { 0, 2, 5, 6, 7, 10, 11, 19, 27, 35, },
+   { 20, 26, 10, },
+   { 21 },
+   { 22 },
+   { 23 },
+   { 24 },
+   { 25 },
+   { 20, 26, 10, },
+   { 0, 2, 5, 6, 7, 10, 11, 19, 27, 35, },
+   { 28 },
+   { 29 },
+   { 30 },
+   { 31 },
+   { 32 },
+   { 33 },
+   { 34 },
+   { 0, 2, 5, 6, 7, 10, 11, 19, 27, 35, },
+   { 36 },
+   { 37 },
+   { 38, 45, 10, },
+   { 39, 46, 6, 10, },
+   { 40, 41, 47, 50, 54, 56, 57, 51, 58, 6, 10, },
+   { 40, 41, 47, 50, 54, 56, 57, 51, 58, 6, 10, },
+   { 42 },
+   { 43 },
+   { 44, 10, },
+   { 38, 45, 10, },
+   { 39, 46, 6, 10, },
+   { 40, 41, 47, 50, 54, 56, 57, 51, 58, 6, 10, },
+   { 48 },
+   { 49 },
+   { 40, 41, 47, 50, 54, 56, 57, 51, 58, 6, 10, },
+   { 40, 41, 47, 50, 54, 56, 57, 51, 58, 6, 10, },
+   { 52 },
+   { 53 },
+   { 40, 41, 47, 50, 54, 56, 57, 51, 58, 6, 10, },
+   { 55 },
+   { 40, 41, 47, 50, 54, 56, 57, 51, 58, 6, 10, },
+   { 40, 41, 47, 50, 54, 56, 57, 51, 58, 6, 10, },
+   { 40, 41, 47, 50, 54, 56, 57, 51, 58, 6, 10, },
+   { 59 },
+ },
+
+};
+protected static final int[][] kindForState = {
+{ 5, 5, 5, 5, 5, 5, 13, 16, 16, 16, 17, 15, 15, 15,
+  15, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 14, 14, 12, 12,
+  12, 12, 12, 12, 12, 12, 11, 6, 6, 6, 6, 6, 6, 6, 7,
+  7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 9, 9, 11,
+  11}
+};
+   int kindCnt = 0;
+  protected  final String jjKindsForBitVector(int i, long vec)
+  {
+    String retVal = "";
+    if (i == 0)
+       kindCnt = 0;
+    for (int j = 0; j < 64; j++)
+    {
+       if ((vec & (1L << j)) != 0L)
+       {
+          if (kindCnt++ > 0)
+             retVal += ", ";
+          if (kindCnt % 5 == 0)
+             retVal += "\n     ";
+          retVal += tokenImage[i * 64 + j];
+       }
+    }
+    return retVal;
+  }
+
+  protected  final String jjKindsForStateVector(int lexState, int[] vec, int start, int end)
+  {
+    boolean[] kindDone = new boolean[18];
+    String retVal = "";
+    int cnt = 0;
+    for (int i = start; i < end; i++)
+    {
+     if (vec[i] == -1)
+       continue;
+     int[] stateSet = statesForState[curLexState][vec[i]];
+     for (int j = 0; j < stateSet.length; j++)
+     {
+       int state = stateSet[j];
+       if (!kindDone[kindForState[lexState][state]])
+       {
+          kindDone[kindForState[lexState][state]] = true;
+          if (cnt++ > 0)
+             retVal += ", ";
+          if (cnt % 5 == 0)
+             retVal += "\n     ";
+          retVal += tokenImage[kindForState[lexState][state]];
+       }
+     }
+    }
+    if (cnt == 0)
+       return "{  }";
+    else
+       return "{ " + retVal + " }";
+  }
+
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+}
Index: src/main/java/demo/Name.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/Name.java	(revision )
+++ src/main/java/demo/Name.java	(revision )
@@ -0,0 +1,177 @@
+package demo;
+
+import com.google.common.base.Joiner;
+import com.google.common.base.Preconditions;
+import com.google.common.base.Predicate;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import org.apache.commons.lang3.StringUtils;
+
+import java.io.Serializable;
+import java.util.List;
+
+public class Name implements Serializable {
+    String salutation;
+    List<String> first = Lists.newArrayList();
+    List<String> middle = Lists.newArrayList();
+    List<String> last = Lists.newArrayList();
+    String relation;  //junior, senior, III etc...
+
+    List<String> names = Lists.newArrayList();
+
+    @Override
+    public String toString() {
+        // CAVEAT : important not to change this. used by wicket models.
+        Iterable<String> nonBlankNames = Iterables.filter(Lists.newArrayList(getSalutation(), getFirst(), getMiddle(), getLast(), getRelation()), new Predicate<String>() {
+            @Override public boolean apply(String s) {
+                return StringUtils.isNotBlank(s);
+            }
+        });
+        return Joiner.on(" ").skipNulls().join(nonBlankNames);
+    }
+
+    public Name withFirstName(String name) {
+        this.first = Lists.newArrayList(name);
+        return this;
+    }
+
+    public Name withLastName(String name) {
+        this.last= Lists.newArrayList(name);
+        return this;
+    }
+
+    public Name withMiddleName(String name) {
+        this.middle = Lists.newArrayList(name);
+        return this;
+    }
+
+    private String unquoted(String name) {
+        return name.replace("\"", "");
+    }
+
+    public String getFirst() {
+        return toString(first);
+    }
+
+    public String getMiddle() {
+        return toString(middle);
+    }
+
+    public String getLast() {
+        return toString(last);
+    }
+
+    public String getSalutation() {
+        return salutation;
+    }
+
+    private String toString(List<String> name) {
+        String text = Joiner.on(" ").skipNulls().join(name);
+        return (name.size()>1) ?
+                "\"" + text + "\"" :
+                text;
+    }
+
+    private boolean isAmbiguous(List<String> name) {
+        return name!=null && name.size()>1;
+    }
+
+    public Name setSalutation(String salutation) {
+        this.salutation = salutation;
+        return this;
+    }
+
+    public Name addFirst(String name) {
+        first.add(unquoted(name));
+        return this;
+    }
+
+    public Name addMiddle(String name) {
+        middle.add(unquoted(name));
+        return this;
+    }
+
+    public Name addLast(String name) {
+        last.add(unquoted(name));
+        return this;
+    }
+
+    public String getRelation() {
+        return relation;
+    }
+
+    public void setRelation(String relation) {
+        this.relation = relation;
+    }
+
+    public Name merge(Name other) {
+        if (!StringUtils.isBlank(salutation) && !StringUtils.isBlank(other.salutation)) {
+            salutation += "/" + other.salutation;
+        }
+        if (getLast().isEmpty()) {
+            last = other.last;
+        } else {
+            last.addAll(other.last);
+        }
+        if (first.isEmpty()) {
+            first = other.first;
+        } else {
+            first.addAll(other.first);
+        }
+        if (StringUtils.isBlank(relation)) {
+            relation = other.relation;
+        }
+        return this;
+    }
+
+    public boolean isAmbiguous() {
+        // note the definition of ambiguous is itself ambiguous.
+        // if you have two last names then it *could* be ambigous.
+        // e.g. john steven dick peterson.   dick could be his last name or middle name.
+        // this will most likely be parsed as john/steven/dick peterson when it could be interpreted as
+        //  john/steven dick/peterson.
+        return isAmbiguous(first) || isAmbiguous(middle) || isAmbiguous(last);
+    }
+
+    public void endParse() {
+        if (names.size()==0) {
+            return;
+        }
+        first.add(names.get(0));
+        if (names.size()==1) {
+            return;
+        } else if (names.size()==2) {
+            last.add(names.get(1));
+            return;
+        }
+        if (names.size()==3) {
+            if (isProbablyMiddleName(names.get(1))) {
+                middle.add(names.get(1));
+                last.addAll(names.subList(2, names.size()));
+            } else {
+                last.addAll(names.subList(1, names.size()));
+            }
+        } else {
+            last.addAll(names.subList(1, names.size()));
+        }
+    }
+
+    public void add(String name) {
+        names.add(name);
+    }
+
+    public boolean isProbablyMiddleName(String name) {
+        // this business logic should be refactored out into a spring bean service.
+        // if nameService.isProbablyNotAMiddleName(name)  name.addLast(name); else name.addMiddle(name);
+        Preconditions.checkArgument(StringUtils.isNotBlank(name));
+        if (name.length()==1||(name.length()==2&&name.endsWith("."))) {
+            return true;
+        }
+        // lots more to put here from different cultures.
+        List<String> notMiddleNames = Lists.newArrayList("van", "le", "la", "di", "mac", "bin", "binti", "de", "o'", "der", "den", "l'");
+        return !notMiddleNames.contains(name.toLowerCase());
+    }
+
+
+
+}
Index: EasyLibrary/src/test/java/com/brovada/easy/widgets/NameParserTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- EasyLibrary/src/test/java/com/brovada/easy/widgets/NameParserTest.java	(revision )
+++ EasyLibrary/src/test/java/com/brovada/easy/widgets/NameParserTest.java	(revision )
@@ -0,0 +1,106 @@
+package com.brovada.easy.widgets;
+
+import junit.framework.TestCase;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+
+public class NameParserTest extends TestCase {
+
+    @Test
+    public void test_NameParser() throws ParseException {
+        NameParser parser = new NameParser(new ByteArrayInputStream("".getBytes()));
+        NameResult name = parser.parseName("mr derek w dick");
+        print(name);
+        name = parser.parseName("mr foo bar really long name and mrs his wife with an even longer name");
+        print(name);
+        name = parser.parseName("derek le van der hoerf-smith jones");
+        print(name);
+        name = parser.parseName("brad pitt");
+        print(name);
+        name = parser.parseName("mr. brad pitt");
+        print(name);
+        name = parser.parseName("mr. brad pitt + angelina jolie");
+        print(name);
+        name = parser.parseName("brad pitt + angelina jolie");
+        print(name);
+        name = parser.parseName("mr joe & mrs steve stevenson");
+        print(name);
+        name = parser.parseName("mister. joe & sue smith");
+        print(name);
+        name = parser.parseName("mrs. joe & ms cathy jones");
+        print(name);
+        name = parser.parseName("mr. \"derek w\" dick");
+        print(name);
+        name = parser.parseName("ms derek w dick");
+        print(name);
+        name = parser.parseName("ms derek w. dick");
+        print(name);
+        name = parser.parseName("sir derek w dick IX");
+        print(name);
+        name = parser.parseName("derek o'flaherty");
+        print(name);
+        name = parser.parseName("mr. joe derek-smith");
+        print(name);
+        name = parser.parseName("joe woo-hoo-toodle-loo jones");
+        print(name);
+        name = parser.parseName("doctor derek dick-smith");
+        print(name);
+        name = parser.parseName("derek \"the killer\" dick");
+        print(name);
+        name = parser.parseName("mr steve smith and ms cathy jones");
+        print(name);
+        name = parser.parseName("joe 'n cathy jones junior");
+        print(name);
+        name = parser.parseName("bill 'n bob r kansas III");
+        print(name);
+        name = parser.parseName("mr joe and ms cathy jones III");
+        print(name);
+        name = parser.parseName("sir richard & mrs dorothy jones");
+        print(name);
+        name = parser.parseName("george w. bush junior");
+        print(name);
+        name = parser.parseName("mr. george bush senior");
+        print(name);
+        name = parser.parseName("sir henry foobar iii");
+        print(name);
+        name = parser.parseName("prince");
+        print(name);
+        name = parser.parseName("the edge");
+        print(name);
+        name = parser.parseName("pele");
+        print(name);
+        name = parser.parseName("pele and prince");
+        print(name);
+        name = parser.parseName("pele and mr steve smith");
+        print(name);
+        name = parser.parseName("pele + mr steve smith");
+        print(name);
+        name = parser.parseName("sir pele and mr steve smith");
+        print(name);
+        name = parser.parseName("mr and mrs steve smith");
+        print(name);
+        name = parser.parseName("mrs and dr steve smith");
+        print(name);
+        name = parser.parseName("mr joe smith and mr steve smith");
+        print(name);
+        name = parser.parseName("mr joe smith iv & steve smith senior");
+        print(name);
+        name = parser.parseName("dr. franklin j washburn-lodge iii and joe \"bone crusher\" jones");
+        print(name);
+        name = parser.parseName("mr and ms steve smith");
+        print(name);
+    }
+
+    private void print(NameResult name) {
+        System.out.println("");
+        System.out.print("  " +name + " " + (name.isTwoPeople() ? " (2)" : "" + (name.mayBeAmbiguous() ? " - ambigious" : "")));
+        if (name.isTwoPeople()) {
+            System.out.println(" merged ==>  : " + name.getName());
+        } else {
+            System.out.println("");
+        }
+    }
+
+
+}
Index: src/main/java/demo/NameParser.jj
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/NameParser.jj	(revision )
+++ src/main/java/demo/NameParser.jj	(revision )
@@ -0,0 +1,128 @@
+options
+{
+    LOOKAHEAD=4;
+    FORCE_LA_CHECK=true;
+    STATIC=false;
+    IGNORE_CASE=true;
+    USER_TOKEN_MANAGER=false;
+    USER_CHAR_STREAM=false;
+}
+
+PARSER_BEGIN(NameParser)
+package demo;
+
+import java.io.*;
+import java.util.*;
+import demo.Name;
+
+
+public class NameParser {
+
+    NameResult names;
+
+    public NameParser() {
+        this(new ByteArrayInputStream("".getBytes()));
+    }
+
+    // use this method...don't call parse() directly!
+    // because need to re-init variables and reset input.
+    public NameResult parseName(String text) throws ParseException, TokenMgrError {
+        System.out.print("parsing..." + text + " : ");
+        init();
+        ReInit(new StringReader(text));
+        _$$parse();
+        return names;
+    }
+
+    private void init() {
+        names = new NameResult();
+        names.push(new Name());
+    }
+
+    public Name getName() {
+        return names.peek();
+    }
+
+}
+PARSER_END(NameParser)
+
+SKIP :
+{
+    " "
+    | "\t"
+    | "\r"
+    | "\n"
+}
+
+TOKEN:
+{
+    <AND:"+"|"&"|"'n"|"and"> |
+    <MR:"mister"|"mr"(".")?> |
+    <MRS:"misses"|"mrs"(".")?> |
+    <MISS:"miss"> |
+    <MADAM:("madam"|"maam"|"mdm"|"mm")> |
+    <SIR:"sir"> |
+    <MS:"ms"(".")?> |
+    <DOCTOR:"doctor"|"dr"(".")?> |
+    <ROMAN_NUMERALS:(["m","c","d","l","i","x","v"])+> |
+    <SENIOR:"sr"(".")?|"senior"> |
+    <JUNIOR:"jr"(".")?|"junior">
+}
+// TODO:refactor nick_name.
+TOKEN : {
+    <NICK_NAME: "\"" (~["\""])+ "\"" > |
+    <NAME : (["a"-"z","-","'","."])+ >
+}
+
+void _$$parse() : {}
+{
+    LOOKAHEAD(shortOrLongName() and())
+       shortOrLongName() and() fullName() end() |
+       fullName() end()
+}
+
+void end() : {}
+{
+    (<EOF>) {names.peek().endParse();}
+}
+
+void shortOrLongName() : {}
+{
+    LOOKAHEAD(salutation())
+        salutation() (name())* (relation())? |
+        (name())+ (relation())?
+}
+
+
+void fullName() : {}
+{
+    (salutation())?
+    (name())+
+    (relation())?
+}
+
+
+void and() : {} {
+    (<AND>)  {
+        names.peek().endParse();
+        names.push(new Name());
+    }
+}
+
+void salutation() : {}
+{
+    (<MR>|<MRS>|<MISS>|<MS>|<SIR>|<MADAM>|<DOCTOR>) {getName().setSalutation(token.image);}
+}
+
+void relation() : {} {
+    (<SENIOR>|<JUNIOR>|<ROMAN_NUMERALS>) {getName().setRelation(token.image);}
+}
+
+void name() : {}
+{
+    LOOKAHEAD(<NICK_NAME>)
+        <NICK_NAME>  { getName().add(token.image); }
+    |
+        <NAME>  { getName().add(token.image); }
+}
+
Index: src/main/java/demo/WicketApplication.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/WicketApplication.java	(revision )
+++ src/main/java/demo/WicketApplication.java	(revision )
@@ -0,0 +1,16 @@
+package demo;
+
+import org.apache.wicket.protocol.http.WebApplication;
+
+public class WicketApplication extends WebApplication {
+
+    public WicketApplication() {
+        super();
+    }
+
+
+    public Class getHomePage() {
+        return HomePage.class;
+    }
+
+}
Index: src/main/java/demo/HomePage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/HomePage.java	(revision )
+++ src/main/java/demo/HomePage.java	(revision )
@@ -0,0 +1,122 @@
+package demo;
+
+import com.google.common.collect.Lists;
+import demo.resources.Resource;
+import org.apache.wicket.Component;
+import org.apache.wicket.markup.head.CssHeaderItem;
+import org.apache.wicket.markup.head.IHeaderResponse;
+import org.apache.wicket.markup.head.JavaScriptReferenceHeaderItem;
+import org.apache.wicket.markup.html.WebMarkupContainer;
+import org.apache.wicket.markup.html.basic.Label;
+import org.apache.wicket.markup.html.WebPage;
+import org.apache.wicket.markup.html.form.Form;
+import org.apache.wicket.markup.html.form.TextField;
+import org.apache.wicket.markup.html.panel.Fragment;
+import org.apache.wicket.model.Model;
+import org.apache.wicket.model.PropertyModel;
+import org.apache.wicket.request.mapper.parameter.PageParameters;
+import org.apache.wicket.request.resource.CssResourceReference;
+import org.apache.wicket.request.resource.JavaScriptResourceReference;
+
+import java.util.List;
+
+public class HomePage extends WebPage {
+
+    private static final JavaScriptResourceReference BOOTSTRAP_JS = new JavaScriptResourceReference(Resource.class, "bootstrap-3.1.1-dist/js/bootstrap.min.js");
+    private static final CssResourceReference BOOTSTRAP_CSS = new CssResourceReference(Resource.class, "bootstrap-3.1.1-dist/css/bootstrap.min.css");
+    private static final JavaScriptResourceReference JQUERY_UI_JS = new JavaScriptResourceReference(Resource.class, "jquery-ui-1.10.4.custom/js/jquery-ui-1.10.4.custom.js");
+    private static final CssResourceReference JQUERY_UI_CSS = new CssResourceReference(Resource.class, "jquery-ui-1.10.4.custom/css/ui-lightness/jquery-ui-1.10.4.custom.min.css");
+    private static final JavaScriptResourceReference MULTISELECT_JS = new JavaScriptResourceReference(Resource.class, "bootstrap-3.1.1-dist/js/bootstrap-multiselect.js");
+    private static final CssResourceReference MULTISELECT_CSS = new CssResourceReference(Resource.class, "bootstrap-3.1.1-dist/css/bootstrap-multiselect.css");
+    private static final JavaScriptResourceReference TYPEAHEAD_JS = new JavaScriptResourceReference(Resource.class, "bootstrap-3.1.1-dist/js/typeahead.bundle.js");
+    private static final CssResourceReference TYPEAHEAD_CSS = new CssResourceReference(Resource.class,"bootstrap-3.1.1-dist/css/typeahead.bootstrap.css");
+
+    public HomePage(final PageParameters parameters) {
+        List<InsuredTab> insured = Lists.newArrayList(
+                new InsuredTab("Petroslav Kablowskisapalbhaala"),
+                new InsuredTab("Derek Dick"),
+                new InsuredTab("John D'oh")
+                );
+        List<ConvictionTab> convictions = Lists.newArrayList(
+                new ConvictionTab("DUI"),
+                new ConvictionTab("robbery"),
+                new ConvictionTab("assault")
+        );
+
+        add(new Form("form").
+            add(new EasyTabbedPanel<InsuredTab>("insured", insured, Model.of("Insured")) {
+                @Override protected InsuredTab createNewTab() {
+                    return new InsuredTab("New Person");
+                }
+            }.withAtLeastOne())
+            .add(new EasyTabbedPanel<ConvictionTab>("convictions", convictions, Model.of("Convictions")) {
+                @Override protected ConvictionTab createNewTab() {
+                    return new ConvictionTab("New Conviction");
+                }
+                @Override protected EasyTabbedPanelOptions getOptions() {
+                    EasyTabbedPanelOptions options = super.getOptions();
+                    options.header.minWidth = "10em";
+                    options.header.maxWidth = "14em";
+                    return options;
+                }
+            }.withZeroOrMore()));
+
+    }
+
+    @Override
+    public void renderHead(IHeaderResponse response) {
+        // TODO : add this to a resource bundle.
+        response.render(JavaScriptReferenceHeaderItem.forReference(JQUERY_UI_JS));
+        response.render(CssHeaderItem.forReference(JQUERY_UI_CSS));
+        response.render(JavaScriptReferenceHeaderItem.forReference(BOOTSTRAP_JS));
+        response.render(CssHeaderItem.forReference(BOOTSTRAP_CSS));
+        response.render(JavaScriptReferenceHeaderItem.forReference(MULTISELECT_JS));
+        response.render(CssHeaderItem.forReference(MULTISELECT_CSS));
+        response.render(JavaScriptReferenceHeaderItem.forReference(TYPEAHEAD_JS));
+        response.render(CssHeaderItem.forReference(TYPEAHEAD_CSS));
+    }
+
+
+    class InsuredTab extends Tab<String> {
+
+        private Address address;
+        private Component name;
+
+        public InsuredTab(String value) {
+            super(value);
+        }
+
+        @Override
+        protected WebMarkupContainer createPanel(String id) {
+            Fragment c = new Fragment(id, "insuredFragment", HomePage.this);
+            c.add(new Label("label","Name"));
+            c.add(setTitleInput(new TextField("text",model)));
+            c.add(new EasyAddress("address", new PropertyModel<Address>(this, "address")));
+            return c;
+        }
+
+    }
+
+    class ConvictionTab extends Tab<String> {
+
+        private String conviction;
+        private Name name;
+        private String car;
+
+        public ConvictionTab(String value) {
+            super(value);
+        }
+
+        @Override
+        protected WebMarkupContainer createPanel(String id) {
+            Fragment c = new Fragment(id, "convictionFragment", HomePage.this);
+            c.add(new Label("label","Conviction"));
+            c.add(setTitleInput(new TextField("conviction",model)));
+            c.add(new EasyName("name",new PropertyModel<Name>(this,"name")));
+            c.add(new Typeahead<String>("typeahead", new PropertyModel<String>(this, "car")));
+            return c;
+        }
+
+
+    }
+}
Index: src/main/java/demo/easyTabbedPanel.css
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/easyTabbedPanel.css	(revision )
+++ src/main/java/demo/easyTabbedPanel.css	(revision )
@@ -0,0 +1,223 @@
+body {
+    font-family: sans-serif;
+    color:#333;
+}
+
+.tab-row {
+    /*only have border when in expanded mode.*/
+    border-bottom:1px solid #ccc;
+    background: #f0f0f0;
+    width: 100%;
+    display: block;
+    height:40px;
+    line-height:40px;
+}
+
+.tab-row ul {
+    float:left;
+    display: block;
+    padding-left:0px;
+    list-style-type: none;
+    margin: 0;
+}
+
+.tab-row ul>li {
+    border-radius:4px 4px 0 0;
+    margin-top:1px;
+    height:100%;
+    position:relative;
+    display: inline-block;
+    border-top: 1px solid #ccc;
+    border-right: 1px solid #ccc;
+    border-bottom: 1px solid #ccc;
+    padding-left:5px;
+    padding-right:5px;
+}
+
+.tab-row>a {
+    text-decoration: none;
+    color:#333;
+}
+
+.tab-row ul .tab-name {
+    float:left;
+    max-width:90%;
+    width:95%;
+    text-decoration: none;
+    display:inline-block;
+    text-overflow: ellipsis;
+    overflow:hidden;
+    white-space:nowrap;
+    color:#669;
+}
+.tab-row ul li:hover a {
+    margin-top:-1px;
+}
+
+.tab-row ul li:hover {
+    text-shadow: 0 0 2px #fea;
+    color:#33c;
+    border-top-width: 2px;
+    border-top-color: cornflowerblue;
+    background: -moz-linear-gradient(top, rgba(226,226,226,1) 0%, rgba(224,224,224,1) 0%, rgba(242,242,242,1) 51%, rgba(254,254,254,1) 100%); /* FF3.6+ */
+    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(226,226,226,1)), color-stop(0%,rgba(224,224,224,1)), color-stop(51%,rgba(242,242,242,1)), color-stop(100%,rgba(254,254,254,1))); /* Chrome,Safari4+ */
+    background: -webkit-linear-gradient(top, rgba(226,226,226,1) 0%,rgba(224,224,224,1) 0%,rgba(242,242,242,1) 51%,rgba(254,254,254,1) 100%); /* Chrome10+,Safari5.1+ */
+    background: -o-linear-gradient(top, rgba(226,226,226,1) 0%,rgba(224,224,224,1) 0%,rgba(242,242,242,1) 51%,rgba(254,254,254,1) 100%); /* Opera 11.10+ */
+    background: -ms-linear-gradient(top, rgba(226,226,226,1) 0%,rgba(224,224,224,1) 0%,rgba(242,242,242,1) 51%,rgba(254,254,254,1) 100%); /* IE10+ */
+    background: linear-gradient(to bottom, rgba(226,226,226,1) 0%,rgba(224,224,224,1) 0%,rgba(242,242,242,1) 51%,rgba(254,254,254,1) 100%); /* W3C */
+}
+
+.tab-row ul>li.current {
+    /*same colour as background of panel below.*/
+    border-bottom:1px solid white;
+    background: -moz-linear-gradient(top, rgba(226,226,226,1) 0%, rgba(224,224,224,1) 0%, rgba(242,242,242,1) 51%, rgba(254,254,254,1) 100%); /* FF3.6+ */
+    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(226,226,226,1)), color-stop(0%,rgba(224,224,224,1)), color-stop(51%,rgba(242,242,242,1)), color-stop(100%,rgba(254,254,254,1))); /* Chrome,Safari4+ */
+    background: -webkit-linear-gradient(top, rgba(226,226,226,1) 0%,rgba(224,224,224,1) 0%,rgba(242,242,242,1) 51%,rgba(254,254,254,1) 100%); /* Chrome10+,Safari5.1+ */
+    background: -o-linear-gradient(top, rgba(226,226,226,1) 0%,rgba(224,224,224,1) 0%,rgba(242,242,242,1) 51%,rgba(254,254,254,1) 100%); /* Opera 11.10+ */
+    background: -ms-linear-gradient(top, rgba(226,226,226,1) 0%,rgba(224,224,224,1) 0%,rgba(242,242,242,1) 51%,rgba(254,254,254,1) 100%); /* IE10+ */
+    background: linear-gradient(to bottom, rgba(226,226,226,1) 0%,rgba(224,224,224,1) 0%,rgba(242,242,242,1) 51%,rgba(254,254,254,1) 100%); /* W3C */
+}
+.tab-row ul>li.current a {
+    color:#333;
+}
+
+.tab-row ul>li.tab-mandatory {
+    border:0px;
+}
+
+.tab-row ul>li.tab-mandatory a {
+    cursor:default;
+}
+
+
+.tab-row ul>li.tab-mandatory .tab-top {
+    display:none;
+}
+.tab-row .tab-add {
+    border-top: 1px solid #ccc;
+    border-right: 1px solid #ccc;
+    height: 29px;
+    margin: 10px 0 0 0;
+    border-radius: 0 4px 0 0;
+    padding-right: 15px;
+    padding-left: 18px;
+    float: left;
+    color:#338433;
+}
+
+
+
+.tab-row .tab-add i {
+    line-height:2;
+}
+
+.tab-row .tab-add:hover {
+    background: -moz-linear-gradient(top, rgba(226,226,226,1) 0%, rgba(224,224,224,1) 0%, rgba(242,242,242,1) 51%, rgba(254,254,254,1) 100%); /* FF3.6+ */
+    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(226,226,226,1)), color-stop(0%,rgba(224,224,224,1)), color-stop(51%,rgba(242,242,242,1)), color-stop(100%,rgba(254,254,254,1))); /* Chrome,Safari4+ */
+    background: -webkit-linear-gradient(top, rgba(226,226,226,1) 0%,rgba(224,224,224,1) 0%,rgba(242,242,242,1) 51%,rgba(254,254,254,1) 100%); /* Chrome10+,Safari5.1+ */
+    background: -o-linear-gradient(top, rgba(226,226,226,1) 0%,rgba(224,224,224,1) 0%,rgba(242,242,242,1) 51%,rgba(254,254,254,1) 100%); /* Opera 11.10+ */
+    background: -ms-linear-gradient(top, rgba(226,226,226,1) 0%,rgba(224,224,224,1) 0%,rgba(242,242,242,1) 51%,rgba(254,254,254,1) 100%); /* IE10+ */
+    background: linear-gradient(to bottom, rgba(226,226,226,1) 0%,rgba(224,224,224,1) 0%,rgba(242,242,242,1) 51%,rgba(254,254,254,1) 100%); /* W3C */
+}
+
+.tab-row .tab-x a i {
+    display:inline-block;
+    font-size:8pt;
+    color:#aaa;
+    float:right;
+    margin-top:2px;
+}
+
+.tab-row .tab-x:hover a i {
+    color:#880000;
+}
+
+/*.tab-row .tab-x:hover a i:before {*/
+    /*content: "\f09c";*/
+/*}*/
+
+div.content {
+    background: yellow;
+}
+
+.tab-row ul {
+    overflow: hidden;
+}
+.tab-row .tab-header {
+    font-size:14px;
+    float:left;
+    margin-left:10px;
+    color:#333;
+}
+
+.tab-row .tab-header p {
+    display:inline;
+}
+
+.tab-row .tab-header:hover {
+    color:#44e;
+    text-decoration: underline;
+}
+
+.tab-row .tabs-expand-collapse {
+    padding-left:5px;
+    padding-right:5px;
+    float:left;
+}
+
+.tab-row .tabs-expand-collapse i {
+    line-height:2;
+}
+
+.tab-content {
+    padding:15px;
+    display:none;
+    top:0;
+    left:0;
+    width:100%;
+}
+
+.tab-content.current {
+    display:block;
+}
+
+.tab-row li:first-of-type {
+    border-left:1px solid #ccc;
+}
+
+div.content {
+    clear: both;
+}
+.tab-panels {
+    position:relative;
+    width:100%;
+    overflow:inherit;
+}
+
+
+body {
+ font-size:14px;
+}
+
+
+
+/* page related....for demo purposes only.*/
+
+main {
+    margin-top:75px;
+}
+
+.col1 {
+    float:left;
+    width:100px;
+}
+
+.col2 {
+    margin-left:100px;
+}
+
+.navbar-brand i {
+    font-size:22px;
+    color:#483d8b;
+    padding-right:8px;
+}
\ No newline at end of file
Index: src/test/java/demo/Start.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/java/demo/Start.java	(revision )
+++ src/test/java/demo/Start.java	(revision )
@@ -0,0 +1,46 @@
+package demo;
+
+import org.mortbay.jetty.Connector;
+import org.mortbay.jetty.Server;
+import org.mortbay.jetty.bio.SocketConnector;
+import org.mortbay.jetty.webapp.WebAppContext;
+
+public class Start {
+
+	public static void main(String[] args) throws Exception {
+		Server server = new Server();
+		SocketConnector connector = new SocketConnector();
+		// Set some timeout options to make debugging easier.
+		connector.setMaxIdleTime(1000 * 60 * 60);
+		connector.setSoLingerTime(-1);
+		connector.setPort(8080);
+		server.setConnectors(new Connector[] { connector });
+
+		WebAppContext bb = new WebAppContext();
+		bb.setServer(server);
+		bb.setContextPath("/");
+		bb.setWar("src/main/webapp");
+
+		
+		// START JMX SERVER
+		// MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
+		// MBeanContainer mBeanContainer = new MBeanContainer(mBeanServer);
+		// server.getContainer().addEventListener(mBeanContainer);
+		// mBeanContainer.start();
+		
+		server.addHandler(bb);
+
+		try {
+			System.out.println(">>> STARTING EMBEDDED JETTY SERVER, PRESS ANY KEY TO STOP");
+			server.start();
+			while (System.in.available() == 0) {
+				Thread.sleep(5000);
+			}
+			server.stop();
+			server.join();
+		} catch (Exception e) {
+			e.printStackTrace();
+			System.exit(100);
+		}
+	}
+}
Index: src/main/java/demo/address.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/address.js	(revision )
+++ src/main/java/demo/address.js	(revision )
@@ -0,0 +1,177 @@
+/**
+ * requires.... 
+ *  <script type="text/javascript" src="http://maps.googleapis.com/maps/api/js?sensor=false"></script> 
+ */
+
+
+// NOTE : where should i package this???
+var easy = easy ? easy : {};
+easy.address = (function() {
+
+    var create = function(options) {
+        var widget = autoCompleteAddress(options);
+        $(options.id).data('address',widget);
+        return widget;
+    }
+
+
+    function autoCompleteAddress(opts) {
+        var defaults = {
+            // any default options like country, city, etc... pass 'em here.
+        };
+        var options = $.extend(defaults, opts);
+        var $address = $(options.id);
+        var $text = $address.find('.txt');
+        var $lat = $address.children('.lat');
+        var $lng = $address.children('.lng');
+        var $street_address = $address.children('.street-address');
+        var $city = $address.children('.city');
+        var $country = $address.children('.country');
+        var $postalCode = $address.children('.postal-code');
+        var $state = $address.children('.state');
+        var currentInput;
+
+        function getAddresses(request, response) {
+            new google.maps.Geocoder().geocode({'address': request.term, region:'CA' }, function(results, status) {
+                if (status == google.maps.GeocoderStatus.OK) {
+                    if (results.length == 0) {
+                        response($.map(results, function(value, i) {
+                            return value.formatted_address;
+                        }));
+                    } else if (results.length > 1) {
+                        if (options.latitude&&options.longitude) {
+                            results = results.sort(function(a,b) {return delta(a,b)})
+                        }
+                        response(results);
+                    }
+                    else {
+                        response(results);
+                    }
+                } else {
+                    response([]);
+                }
+            });
+
+        };
+
+        function extractFromGeoCode(components, type) {
+            for (var i = 0; i < components.length; i++) {
+                for (var j = 0; j < components[i].types.length; j++) {
+                    if (components[i].types[j] == type)
+                        return components[i].long_name;
+                }
+            }
+            return "";
+        }
+
+        function updateNonAddress(textInput) {
+            update(textInput);
+        }
+
+        function toRad(x) {
+            return x * Math.PI / 180;
+        }
+
+        function delta(a,b) {
+            a.distance = a.distance ? a.distance : distance(a);
+            b.distance = b.distance ? b.distance : distance(b);
+            return a.distance-b.distance;
+        }
+
+        function distance(pt) {
+            if (!options.latitude || !options.longitude) {
+                throw('you need to specify location bias');
+            }
+            var lat1 = pt.geometry.location.lat();
+            var lng1 = pt.geometry.location.lng();
+            var lat2 = options.latitude;
+            var lng2 = options.longitude;
+
+            var R = 6371; // km
+            var x1 = lat2-lat1;
+            var dLat = toRad(x1);
+            var x2 = lng2-lng1;
+            var dLon = toRad(x2);
+            var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
+                    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
+                    Math.sin(dLon/2) * Math.sin(dLon/2);
+            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
+            var d = R * c;
+            console.log('dist ' + lat1 + ' , ' + lng1 + ' = ' + d);
+            return d;
+        }
+
+        function updateAddress(item) {
+            update(item.formatted_address, item.geometry.location, item.address_components);
+        }
+
+        function update(formattedAddress, latLng, addressInfo) {
+            $text.val(formattedAddress);
+            if (latLng) {
+                $lat.val(latLng.lat());
+                $lng.val(latLng.lng());
+            } else { 
+                $lat.val(null);
+                $lng.val(null);
+            }
+
+            if (addressInfo) {
+                $street_address.val(extractFromGeoCode(addressInfo, 'street_number') + ' ' + extractFromGeoCode(addressInfo, 'route'));
+                $city.val(extractFromGeoCode(addressInfo, 'locality'));
+                $country.val(extractFromGeoCode(addressInfo, 'country'));
+                $postalCode.val(extractFromGeoCode(addressInfo, 'postal_code'));
+                $state.val(extractFromGeoCode(addressInfo, 'administrative_area_level_1'));
+            } else {
+                $street_address.val(null);
+                $city.val(null);
+                $country.val(null);
+                $postalCode.val(null);
+                $state.val(null);
+            }
+
+            currentInput = $text.val();
+        }
+
+        var textOptions = {
+            delay: 500,
+            minLength: 1,
+            source: function(request, response) {
+                getAddresses(request, response);
+            },
+            select: function(event, ui) {
+                updateAddress(ui.item);
+                return false;
+            },
+            change: function(a, b) {
+                // address is NOT a selected value, just some random input so we'll remove any gps, postal code, country etc... values.
+                if (currentInput != $text.val()) {
+                    updateNonAddress($text.val());
+                }
+                return false;
+            }
+        };
+
+        if ($text.size() > 0) {
+            $text.autocomplete(textOptions).data('ui-autocomplete')._renderItem = function(ul, item) {
+                    return $("<li></li>")
+                            .data("item.autocomplete", item)
+                            .append("<a>" + item.formatted_address + "</a>")
+                            .appendTo(ul);
+                };
+        }
+
+        return {
+            // no exposed API for autoComplete widget yet.
+        };
+
+    }
+
+    return {
+        create: create
+    };
+
+})();
+
+
+
+
Index: src/main/java/demo/NameParser.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/NameParser.java	(revision )
+++ src/main/java/demo/NameParser.java	(revision )
@@ -0,0 +1,948 @@
+/* Generated By:JavaCC: Do not edit this line. NameParser.java */
+package demo;
+
+import java.io.*;
+import java.util.*;
+import demo.Name;
+
+
+public class NameParser implements NameParserConstants {
+
+    NameResult names;
+
+    public NameParser() {
+        this(new ByteArrayInputStream("".getBytes()));
+    }
+
+    // use this method...don't call parse() directly!
+    // because need to re-init variables and reset input.
+    public NameResult parseName(String text) throws ParseException, TokenMgrError {
+        System.out.print("parsing..." + text + " : ");
+        init();
+        ReInit(new StringReader(text));
+        _$$parse();
+        return names;
+    }
+
+    private void init() {
+        names = new NameResult();
+        names.push(new Name());
+    }
+
+    public Name getName() {
+        return names.peek();
+    }
+
+  final public void _$$parse() throws ParseException {
+    trace_call("_$$parse");
+    try {
+      if (jj_2_1(2147483647)) {
+        shortOrLongName();
+        and();
+        fullName();
+        end();
+      } else if (jj_2_2(4)) {
+        fullName();
+        end();
+      } else {
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } finally {
+      trace_return("_$$parse");
+    }
+  }
+
+  final public void end() throws ParseException {
+    trace_call("end");
+    try {
+      jj_consume_token(0);
+             names.peek().endParse();
+    } finally {
+      trace_return("end");
+    }
+  }
+
+  final public void shortOrLongName() throws ParseException {
+    trace_call("shortOrLongName");
+    try {
+      if (jj_2_7(2147483647)) {
+        salutation();
+        label_1:
+        while (true) {
+          if (jj_2_3(4)) {
+            ;
+          } else {
+            break label_1;
+          }
+          name();
+        }
+        if (jj_2_4(4)) {
+          relation();
+        } else {
+          ;
+        }
+      } else if (jj_2_8(4)) {
+        label_2:
+        while (true) {
+          name();
+          if (jj_2_5(4)) {
+            ;
+          } else {
+            break label_2;
+          }
+        }
+        if (jj_2_6(4)) {
+          relation();
+        } else {
+          ;
+        }
+      } else {
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } finally {
+      trace_return("shortOrLongName");
+    }
+  }
+
+  final public void fullName() throws ParseException {
+    trace_call("fullName");
+    try {
+      if (jj_2_9(4)) {
+        salutation();
+      } else {
+        ;
+      }
+      label_3:
+      while (true) {
+        name();
+        if (jj_2_10(4)) {
+          ;
+        } else {
+          break label_3;
+        }
+      }
+      if (jj_2_11(4)) {
+        relation();
+      } else {
+        ;
+      }
+    } finally {
+      trace_return("fullName");
+    }
+  }
+
+  final public void and() throws ParseException {
+    trace_call("and");
+    try {
+      jj_consume_token(AND);
+        names.peek().endParse();
+        names.push(new Name());
+    } finally {
+      trace_return("and");
+    }
+  }
+
+  final public void salutation() throws ParseException {
+    trace_call("salutation");
+    try {
+      if (jj_2_12(4)) {
+        jj_consume_token(MR);
+      } else if (jj_2_13(4)) {
+        jj_consume_token(MRS);
+      } else if (jj_2_14(4)) {
+        jj_consume_token(MISS);
+      } else if (jj_2_15(4)) {
+        jj_consume_token(MS);
+      } else if (jj_2_16(4)) {
+        jj_consume_token(SIR);
+      } else if (jj_2_17(4)) {
+        jj_consume_token(MADAM);
+      } else if (jj_2_18(4)) {
+        jj_consume_token(DOCTOR);
+      } else {
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+                                                     getName().setSalutation(token.image);
+    } finally {
+      trace_return("salutation");
+    }
+  }
+
+  final public void relation() throws ParseException {
+    trace_call("relation");
+    try {
+      if (jj_2_19(4)) {
+        jj_consume_token(SENIOR);
+      } else if (jj_2_20(4)) {
+        jj_consume_token(JUNIOR);
+      } else if (jj_2_21(4)) {
+        jj_consume_token(ROMAN_NUMERALS);
+      } else {
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+                                          getName().setRelation(token.image);
+    } finally {
+      trace_return("relation");
+    }
+  }
+
+  final public void name() throws ParseException {
+    trace_call("name");
+    try {
+      if (jj_2_22(2147483647)) {
+        jj_consume_token(NICK_NAME);
+                       getName().add(token.image);
+      } else if (jj_2_23(4)) {
+        jj_consume_token(NAME);
+                  getName().add(token.image);
+      } else {
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } finally {
+      trace_return("name");
+    }
+  }
+
+  private boolean jj_2_1(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_1(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(0, xla); }
+  }
+
+  private boolean jj_2_2(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_2(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(1, xla); }
+  }
+
+  private boolean jj_2_3(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_3(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(2, xla); }
+  }
+
+  private boolean jj_2_4(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_4(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(3, xla); }
+  }
+
+  private boolean jj_2_5(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_5(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(4, xla); }
+  }
+
+  private boolean jj_2_6(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_6(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(5, xla); }
+  }
+
+  private boolean jj_2_7(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_7(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(6, xla); }
+  }
+
+  private boolean jj_2_8(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_8(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(7, xla); }
+  }
+
+  private boolean jj_2_9(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_9(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(8, xla); }
+  }
+
+  private boolean jj_2_10(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_10(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(9, xla); }
+  }
+
+  private boolean jj_2_11(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_11(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(10, xla); }
+  }
+
+  private boolean jj_2_12(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_12(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(11, xla); }
+  }
+
+  private boolean jj_2_13(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_13(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(12, xla); }
+  }
+
+  private boolean jj_2_14(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_14(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(13, xla); }
+  }
+
+  private boolean jj_2_15(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_15(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(14, xla); }
+  }
+
+  private boolean jj_2_16(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_16(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(15, xla); }
+  }
+
+  private boolean jj_2_17(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_17(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(16, xla); }
+  }
+
+  private boolean jj_2_18(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_18(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(17, xla); }
+  }
+
+  private boolean jj_2_19(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_19(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(18, xla); }
+  }
+
+  private boolean jj_2_20(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_20(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(19, xla); }
+  }
+
+  private boolean jj_2_21(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_21(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(20, xla); }
+  }
+
+  private boolean jj_2_22(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_22(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(21, xla); }
+  }
+
+  private boolean jj_2_23(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_23(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(22, xla); }
+  }
+
+  private boolean jj_3R_7() {
+    if (!jj_rescan) trace_call("end(LOOKING AHEAD...)");
+    if (jj_scan_token(0)) { if (!jj_rescan) trace_return("end(LOOKAHEAD FAILED)"); return true; }
+    { if (!jj_rescan) trace_return("end(LOOKAHEAD SUCCEEDED)"); return false; }
+  }
+
+  private boolean jj_3_22() {
+    if (jj_scan_token(NICK_NAME)) return true;
+    return false;
+  }
+
+  private boolean jj_3_15() {
+    if (jj_scan_token(MS)) return true;
+    return false;
+  }
+
+  private boolean jj_3_2() {
+    if (jj_3R_6()) return true;
+    if (jj_3R_7()) return true;
+    return false;
+  }
+
+  private boolean jj_3_23() {
+    if (jj_scan_token(NAME)) return true;
+    return false;
+  }
+
+  private boolean jj_3_20() {
+    if (jj_scan_token(JUNIOR)) return true;
+    return false;
+  }
+
+  private boolean jj_3_14() {
+    if (jj_scan_token(MISS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_12() {
+    if (jj_scan_token(NICK_NAME)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_8() {
+    if (!jj_rescan) trace_call("name(LOOKING AHEAD...)");
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_12()) {
+    jj_scanpos = xsp;
+    if (jj_3_23()) { if (!jj_rescan) trace_return("name(LOOKAHEAD FAILED)"); return true; }
+    }
+    { if (!jj_rescan) trace_return("name(LOOKAHEAD SUCCEEDED)"); return false; }
+  }
+
+  private boolean jj_3_4() {
+    if (jj_3R_9()) return true;
+    return false;
+  }
+
+  private boolean jj_3_13() {
+    if (jj_scan_token(MRS)) return true;
+    return false;
+  }
+
+  private boolean jj_3_19() {
+    if (jj_scan_token(SENIOR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_9() {
+    if (!jj_rescan) trace_call("relation(LOOKING AHEAD...)");
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_19()) {
+    jj_scanpos = xsp;
+    if (jj_3_20()) {
+    jj_scanpos = xsp;
+    if (jj_3_21()) { if (!jj_rescan) trace_return("relation(LOOKAHEAD FAILED)"); return true; }
+    }
+    }
+    { if (!jj_rescan) trace_return("relation(LOOKAHEAD SUCCEEDED)"); return false; }
+  }
+
+  private boolean jj_3_12() {
+    if (jj_scan_token(MR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_10() {
+    if (!jj_rescan) trace_call("salutation(LOOKING AHEAD...)");
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_12()) {
+    jj_scanpos = xsp;
+    if (jj_3_13()) {
+    jj_scanpos = xsp;
+    if (jj_3_14()) {
+    jj_scanpos = xsp;
+    if (jj_3_15()) {
+    jj_scanpos = xsp;
+    if (jj_3_16()) {
+    jj_scanpos = xsp;
+    if (jj_3_17()) {
+    jj_scanpos = xsp;
+    if (jj_3_18()) { if (!jj_rescan) trace_return("salutation(LOOKAHEAD FAILED)"); return true; }
+    }
+    }
+    }
+    }
+    }
+    }
+    { if (!jj_rescan) trace_return("salutation(LOOKAHEAD SUCCEEDED)"); return false; }
+  }
+
+  private boolean jj_3_3() {
+    if (jj_3R_8()) return true;
+    return false;
+  }
+
+  private boolean jj_3_6() {
+    if (jj_3R_9()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_5() {
+    if (!jj_rescan) trace_call("and(LOOKING AHEAD...)");
+    if (jj_scan_token(AND)) { if (!jj_rescan) trace_return("and(LOOKAHEAD FAILED)"); return true; }
+    { if (!jj_rescan) trace_return("and(LOOKAHEAD SUCCEEDED)"); return false; }
+  }
+
+  private boolean jj_3_18() {
+    if (jj_scan_token(DOCTOR)) return true;
+    return false;
+  }
+
+  private boolean jj_3_11() {
+    if (jj_3R_9()) return true;
+    return false;
+  }
+
+  private boolean jj_3_7() {
+    if (jj_3R_10()) return true;
+    return false;
+  }
+
+  private boolean jj_3_10() {
+    if (jj_3R_8()) return true;
+    return false;
+  }
+
+  private boolean jj_3_9() {
+    if (jj_3R_10()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_6() {
+    if (!jj_rescan) trace_call("fullName(LOOKING AHEAD...)");
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_9()) jj_scanpos = xsp;
+    if (jj_3_10()) { if (!jj_rescan) trace_return("fullName(LOOKAHEAD FAILED)"); return true; }
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_10()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_3_11()) jj_scanpos = xsp;
+    { if (!jj_rescan) trace_return("fullName(LOOKAHEAD SUCCEEDED)"); return false; }
+  }
+
+  private boolean jj_3_5() {
+    if (jj_3R_8()) return true;
+    return false;
+  }
+
+  private boolean jj_3_8() {
+    Token xsp;
+    if (jj_3_5()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_5()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_3_6()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_17() {
+    if (jj_scan_token(MADAM)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_11() {
+    if (jj_3R_10()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_3()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_3_4()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_4() {
+    if (!jj_rescan) trace_call("shortOrLongName(LOOKING AHEAD...)");
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_11()) {
+    jj_scanpos = xsp;
+    if (jj_3_8()) { if (!jj_rescan) trace_return("shortOrLongName(LOOKAHEAD FAILED)"); return true; }
+    }
+    { if (!jj_rescan) trace_return("shortOrLongName(LOOKAHEAD SUCCEEDED)"); return false; }
+  }
+
+  private boolean jj_3_16() {
+    if (jj_scan_token(SIR)) return true;
+    return false;
+  }
+
+  private boolean jj_3_21() {
+    if (jj_scan_token(ROMAN_NUMERALS)) return true;
+    return false;
+  }
+
+  private boolean jj_3_1() {
+    if (jj_3R_4()) return true;
+    if (jj_3R_5()) return true;
+    return false;
+  }
+
+  /** Generated Token Manager. */
+  public NameParserTokenManager token_source;
+  SimpleCharStream jj_input_stream;
+  /** Current token. */
+  public Token token;
+  /** Next token. */
+  public Token jj_nt;
+  private int jj_ntk;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[0];
+  static private int[] jj_la1_0;
+  static {
+      jj_la1_init_0();
+   }
+   private static void jj_la1_init_0() {
+      jj_la1_0 = new int[] {};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[23];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  /** Constructor with InputStream. */
+  public NameParser(java.io.InputStream stream) {
+     this(stream, null);
+  }
+  /** Constructor with InputStream and supplied encoding */
+  public NameParser(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new NameParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
+  }
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor. */
+  public NameParser(java.io.Reader stream) {
+    jj_input_stream = new SimpleCharStream(stream, 1, 1);
+    token_source = new NameParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor with generated Token Manager. */
+  public NameParser(NameParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(NameParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken;
+    if ((oldToken = token).next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    if (token.kind == kind) {
+      jj_gen++;
+      if (++jj_gc > 100) {
+        jj_gc = 0;
+        for (int i = 0; i < jj_2_rtns.length; i++) {
+          JJCalls c = jj_2_rtns[i];
+          while (c != null) {
+            if (c.gen < jj_gen) c.first = null;
+            c = c.next;
+          }
+        }
+      }
+      trace_token(token, "");
+      return token;
+    }
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+  static private final class LookaheadSuccess extends java.lang.Error { }
+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
+  private boolean jj_scan_token(int kind) {
+    if (jj_scanpos == jj_lastpos) {
+      jj_la--;
+      if (jj_scanpos.next == null) {
+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
+      } else {
+        jj_lastpos = jj_scanpos = jj_scanpos.next;
+      }
+    } else {
+      jj_scanpos = jj_scanpos.next;
+    }
+    if (jj_rescan) {
+      int i = 0; Token tok = token;
+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
+      if (tok != null) jj_add_error_token(kind, i);
+    } else {
+      trace_scan(jj_scanpos, kind);
+    }
+    if (jj_scanpos.kind != kind) return true;
+    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
+    return false;
+  }
+
+
+/** Get the next Token. */
+  final public Token getNextToken() {
+    if (token.next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    jj_gen++;
+      trace_token(token, " (in getNextToken)");
+    return token;
+  }
+
+/** Get the specific Token. */
+  final public Token getToken(int index) {
+    Token t = token;
+    for (int i = 0; i < index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private int jj_ntk() {
+    if ((jj_nt=token.next) == null)
+      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
+    else
+      return (jj_ntk = jj_nt.kind);
+  }
+
+  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+  private int[] jj_lasttokens = new int[100];
+  private int jj_endpos;
+
+  private void jj_add_error_token(int kind, int pos) {
+    if (pos >= 100) return;
+    if (pos == jj_endpos + 1) {
+      jj_lasttokens[jj_endpos++] = kind;
+    } else if (jj_endpos != 0) {
+      jj_expentry = new int[jj_endpos];
+      for (int i = 0; i < jj_endpos; i++) {
+        jj_expentry[i] = jj_lasttokens[i];
+      }
+      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
+        int[] oldentry = (int[])(it.next());
+        if (oldentry.length == jj_expentry.length) {
+          for (int i = 0; i < jj_expentry.length; i++) {
+            if (oldentry[i] != jj_expentry[i]) {
+              continue jj_entries_loop;
+            }
+          }
+          jj_expentries.add(jj_expentry);
+          break jj_entries_loop;
+        }
+      }
+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
+    }
+  }
+
+  /** Generate ParseException. */
+  public ParseException generateParseException() {
+    jj_expentries.clear();
+    boolean[] la1tokens = new boolean[18];
+    if (jj_kind >= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i < 0; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j < 32; j++) {
+          if ((jj_la1_0[i] & (1<<j)) != 0) {
+            la1tokens[j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i < 18; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.add(jj_expentry);
+      }
+    }
+    jj_endpos = 0;
+    jj_rescan_token();
+    jj_add_error_token(0, 0);
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i < jj_expentries.size(); i++) {
+      exptokseq[i] = jj_expentries.get(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  private int trace_indent = 0;
+  private boolean trace_enabled = true;
+
+/** Enable tracing. */
+  final public void enable_tracing() {
+    trace_enabled = true;
+  }
+
+/** Disable tracing. */
+  final public void disable_tracing() {
+    trace_enabled = false;
+  }
+
+  private void trace_call(String s) {
+    if (trace_enabled) {
+      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
+      System.out.println("Call:   " + s);
+    }
+    trace_indent = trace_indent + 2;
+  }
+
+  private void trace_return(String s) {
+    trace_indent = trace_indent - 2;
+    if (trace_enabled) {
+      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
+      System.out.println("Return: " + s);
+    }
+  }
+
+  private void trace_token(Token t, String where) {
+    if (trace_enabled) {
+      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
+      System.out.print("Consumed token: <" + tokenImage[t.kind]);
+      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
+        System.out.print(": \"" + t.image + "\"");
+      }
+      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
+    }
+  }
+
+  private void trace_scan(Token t1, int t2) {
+    if (trace_enabled) {
+      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
+      System.out.print("Visited token: <" + tokenImage[t1.kind]);
+      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
+        System.out.print(": \"" + t1.image + "\"");
+      }
+      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
+    }
+  }
+
+  private void jj_rescan_token() {
+    jj_rescan = true;
+    for (int i = 0; i < 23; i++) {
+    try {
+      JJCalls p = jj_2_rtns[i];
+      do {
+        if (p.gen > jj_gen) {
+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
+          switch (i) {
+            case 0: jj_3_1(); break;
+            case 1: jj_3_2(); break;
+            case 2: jj_3_3(); break;
+            case 3: jj_3_4(); break;
+            case 4: jj_3_5(); break;
+            case 5: jj_3_6(); break;
+            case 6: jj_3_7(); break;
+            case 7: jj_3_8(); break;
+            case 8: jj_3_9(); break;
+            case 9: jj_3_10(); break;
+            case 10: jj_3_11(); break;
+            case 11: jj_3_12(); break;
+            case 12: jj_3_13(); break;
+            case 13: jj_3_14(); break;
+            case 14: jj_3_15(); break;
+            case 15: jj_3_16(); break;
+            case 16: jj_3_17(); break;
+            case 17: jj_3_18(); break;
+            case 18: jj_3_19(); break;
+            case 19: jj_3_20(); break;
+            case 20: jj_3_21(); break;
+            case 21: jj_3_22(); break;
+            case 22: jj_3_23(); break;
+          }
+        }
+        p = p.next;
+      } while (p != null);
+      } catch(LookaheadSuccess ls) { }
+    }
+    jj_rescan = false;
+  }
+
+  private void jj_save(int index, int xla) {
+    JJCalls p = jj_2_rtns[index];
+    while (p.gen > jj_gen) {
+      if (p.next == null) { p = p.next = new JJCalls(); break; }
+      p = p.next;
+    }
+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
+  }
+
+  static final class JJCalls {
+    int gen;
+    Token first;
+    int arg;
+    JJCalls next;
+  }
+
+}
Index: src/main/java/demo/easyTabbedPanel.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/easyTabbedPanel.js	(revision )
+++ src/main/java/demo/easyTabbedPanel.js	(revision )
@@ -0,0 +1,138 @@
+
+var easy = easy ? easy : {};
+
+
+easy.tabPanel = (function() {
+
+    var defaultOptions = {
+        header : {
+            minWidth : '7em',
+            paddingRight: '50px',
+            maxWidth : '110em'
+        }
+    };
+
+    var init = function(options) {
+        $('#'+options.id).tabPanel = tabPanel($.extend(defaultOptions,options));
+    }
+
+    var expandAll = function() {
+        $('#'+options.id + ' .tab-panels').show();
+    }
+
+    var collapseAll = function() {
+        $('#'+options.id + ' .tab-panels').hide();
+    }
+
+
+
+    function tabPanel(options) {
+        var id = options.id;
+        var $tabPanel = $('#'+id);
+        var options = options;
+        var current = options.current;
+        var $panels = $('#'+options.id + ' .tab-panels');
+        var $header = $tabPanel.find('.tab-header');
+
+
+        function updatePopover(li,text,init) {
+            if (init) {
+                li.popover({
+                    trigger: 'hover',
+                    'placement': 'bottom'
+                });
+            }
+            // HACK...scrollwidth doesn't work for li so i hack it to use child and add fudge factor. FIX THIS.
+            var popoverState = li.find('span').outerWidth()+36 <= li[0].scrollWidth ? 'disable' : 'enable';
+            li.popover(popoverState);
+            li.attr('data-content', text);
+        }
+
+        function layout() {
+            var $tabList = $tabPanel.find('ul');
+
+            var width = $tabPanel.find('.tab-row').width() - $header.width() - 32;  // - size of status icon at end?
+            var $tabs = $tabPanel.find('ul li');
+            // how many tabs...how much room for each??
+            var tabCount  = $tabs.length;
+            var size = Math.floor(width/(tabCount+1))+'px';
+            $tabs.css({minWidth:size,maxWidth:size});
+            // TODO : if > maxTabs, throw the excess in another <ul class="extra-tabs"><li>blah</li></ul>
+            // have minTazbWidth option.
+            $tabPanel.find('.tab-header').css(options.header);
+            $.each(options.titleInputs,function(index,input) {
+                if(!input) return;
+                var $input = $(input);
+                var $link = $($tabPanel.find('li .tab-name')[index]);
+                // only show popover if name is too long to fit in tab.
+                $input.keypress(function() {
+                    setTimeout(function() {
+                        $link.find('span').text($input.val());
+                        updatePopover($link.parent(), $input.val());
+                    },50);
+                });
+                // chrome doesn't fire backspace key events? why.  this hack covers up that flaw...ugly.
+                $input.keyup(function(e) {
+                    if (!e.charCode) {
+                        $(this).trigger('keypress', e);
+                    }
+                });
+            });
+
+        }
+
+        if (options.collapsed) {
+            $panels.hide();
+        }
+
+        // need to deal with state of icon here.  triangle down/right etc...
+        $header.click(function(e) {
+            $panels.toggle();
+        });
+
+        var selectTab = function(index) {
+            // deselect current...
+            $tabPanel.find('li.current').removeClass('current');
+            $tabPanel.find('.tab-content.current').removeClass('current');
+            // ...select new one.
+            $tabPanel.find(' ul li').eq(index).addClass('current');
+            $tabPanel.find(' .tab-content').eq(index).addClass('current');
+        }
+
+        var selectLastTab = function() {
+            selectTab($tabPanel.find('ul li').length-1);
+        };
+
+        var selectFirstTab = function() {
+            selectTab(0);
+        };
+
+        layout();
+
+        selectTab(options.current);
+
+        $tabPanel.find(' ul li').click(function(e) {
+            selectTab($(this).index())
+        });
+
+        $.each($tabPanel.find('.tab-list li'),function(index,li) {
+            var $tab = $(li);
+            updatePopover($tab,$tab.find('a span').text(),true);
+        });
+
+        return {
+            selectFirstTab : selectFirstTab,
+            selectLastTab: selectLastTab
+        }
+
+    }
+
+    return {
+        init : init,
+        expandAll : expandAll,
+        collapseAll : collapseAll
+    }
+
+
+
+})();
Index: src/main/java/demo/typeahead.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/typeahead.js	(revision )
+++ src/main/java/demo/typeahead.js	(revision )
@@ -0,0 +1,65 @@
+var easy = easy ? easy : {};
+
+easy.typeahead = (function() {
+
+    var defaultOptions = {
+    };
+
+    var init = function(options) {
+        var widget = $('#'+options.id);
+        widget.tah = tah($.extend(defaultOptions,options));
+        return widget;
+    }
+
+    function tah(options) {
+        var $text = $('#'+options.id);
+        var source = new Bloodhound({
+            datumTokenizer: Bloodhound.tokenizers.obj.whitespace('car'),
+            queryTokenizer: Bloodhound.tokenizers.whitespace,
+            local: [{ car:"Audi" }, { car:"Chevy" }, { car:"Ford" }, { car:"Honda" }, { car:"Volkswagen" }, { car:"Mazda" }, { car:"Hyundai" }, { car:"BMW" }, { car:"Vauxhall" }, { car:"Toyota" } ]
+        });
+        source.initialize();
+
+        function getWordAtCursor(that) {
+            // NOTE : this won't work on IE!
+            var selection = that.$element.get(0).selectionStart;
+            var text = that.query;
+            var start = Math.min(selection,text.length);
+            for (var from=start; from>=0; from--) {
+                if (text.charAt(from)==' ') {
+                    break;
+                }
+            }
+            for (var to=start; to<text.length; to++) {
+                if (text.charAt(to)==' ') {
+                    break;
+                }
+            }
+            return text.substring(from,to).trim();
+        }
+
+        function matcher(item) {
+            //ignore non-alphanumeric keys...where contents don't change.
+            var word=getWordAtCursor(this);
+            // need to account for items with spaces in them.
+            if (word.length===0) {
+                return false;
+            }
+            return ~item.toLowerCase().indexOf(word.toLowerCase());
+        }
+
+        function updater(item) {
+            var word = getWordAtCursor(this);
+            return this.$element.get(0).value.replace(word,item);
+        }
+
+        $text.typeahead({ hint:true, highlight:true, minLength:1 },
+            { name:'cars', displayKey: 'car', source:source.ttAdapter() }
+        );
+    }
+
+    return {
+        init : init
+    }
+
+})();
\ No newline at end of file
Index: src/main/java/demo/HomePage.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/HomePage.html	(revision )
+++ src/main/java/demo/HomePage.html	(revision )
@@ -0,0 +1,147 @@
+<html lang="en">
+<head>
+    <meta charset="utf-8">
+    <meta http-equiv="X-UA-Compatible" content="IE=edge">
+    <meta name="viewport" content="width=device-width, initial-scale=1">
+    <meta name="description" content="">
+    <meta name="author" content="">
+    <link rel="shortcut icon" href="../../assets/ico/favicon.ico">
+    <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
+
+    <title>Brovada Demo</title>
+
+
+    <style id="clearly_highlighting_css" type="text/css">
+        html.clearly_highlighting_enabled ::-moz-selection { background: rgba(246, 238, 150, 0.99); }
+        html.clearly_highlighting_enabled ::selection { background: rgba(246, 238, 150, 0.99); }
+        html.clearly_highlighting_enabled { cursor: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--cursor.png") 14 16, text; } /* highlight tag */ em.clearly_highlight_element {    font-style: inherit !important; font-weight: inherit !important;    background-image: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--yellow.png");    background-repeat: repeat-x; background-position: top left; background-size: 100% 100%; } /* the delete-buttons are positioned relative to this */ em.clearly_highlight_element.clearly_highlight_first { position: relative; } /* delete buttons */ em.clearly_highlight_element a.clearly_highlight_delete_element {    display: none; cursor: pointer;    padding: 0; margin: 0; line-height: 0;    position: absolute; width: 34px; height: 34px; left: -17px; top: -17px;    background-image: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--delete-sprite.png"); background-repeat: no-repeat; background-position: 0px 0px; } em.clearly_highlight_element a.clearly_highlight_delete_element:hover { background-position: -34px 0px; } /* retina */ @media (min--moz-device-pixel-ratio: 2), (-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2) {    em.clearly_highlight_element { background-image: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--yellow@2x.png"); }    em.clearly_highlight_element a.clearly_highlight_delete_element { background-image: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--delete-sprite@2x.png"); background-size: 68px 34px; } } </style><style type="text/css"></style><style>[touch-action="none"]{ -ms-touch-action: none; touch-action: none; }[touch-action="pan-x"]{ -ms-touch-action: pan-x; touch-action: pan-x; }[touch-action="pan-y"]{ -ms-touch-action: pan-y; touch-action: pan-y; }[touch-action="scroll"],[touch-action="pan-x pan-y"],[touch-action="pan-y pan-x"]{ -ms-touch-action: pan-x pan-y; touch-action: pan-x pan-y; }
+    </style>
+
+
+
+</head>
+
+<body>
+
+
+
+
+
+<!-- Fixed navbar -->
+<div class="navbar navbar-default navbar-fixed-top" role="navigation">
+    <div class="container">
+        <div class="navbar-header">
+            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
+                <span class="sr-only">Toggle navigation</span>
+                <span class="icon-bar"></span>
+                <span class="icon-bar"></span>
+                <span class="icon-bar"></span>
+            </button>
+            <a class="navbar-brand" href="#"><i class="fa fa-camera-retro"></i>Brovada One</a>
+        </div>
+        <div class="navbar-collapse collapse">
+            <ul class="nav navbar-nav">
+                <li class="active"><a href="#">Auto</a></li>
+                <li><a href="#about">Residential</a></li>
+                <li><a href="#contact">Commercial</a></li>
+            </ul>
+            <ul class="nav navbar-nav navbar-right">
+                <li class="dropdown">
+                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Transactions <b class="caret"></b></a>
+                    <ul class="dropdown-menu">
+                        <li><a href="#">Create a new policy</a></li>
+                        <li><a href="#">Inquire about a policy</a></li>
+                        <li><a href="#">Modify a policy</a></li>
+                        <li class="divider"></li>
+                        <li class="dropdown-header">Carrier Specific</li>
+                        <li><a href="#">FooBar</a></li>
+                        <li><a href="#">Update my info</a></li>
+                    </ul>
+                </li><li><a>Portals</a></li>
+                <li><a>Account</a></li>
+                <li class="active"><a>Support</a></li>
+            </ul>
+        </div><!--/.nav-collapse -->
+    </div>
+</div>
+
+
+<ol class="breadcrumb">
+    <li><a href="#">Auto</a></li>
+    <li><a href="#">New Policy</a></li>
+    <li class="active">John D'oh</li>
+</ol>
+
+<main class="container">
+
+    <form wicket:id="form" role="form">
+        <div class="form-group">
+        <span wicket:id="insured"></span>
+        </div>
+        <br>
+        <div class="form-group">
+            <span wicket:id="convictions"></span>
+        </div>
+    </form>
+
+</main> <!-- /container -->
+
+
+
+<wicket:fragment wicket:id="insuredFragment">
+    <div class="form-group">
+    <label wicket:id="label"></label>
+        <input wicket:id="text" type="text" class="form-control" placeholder="Enter Name" required>
+        <label>Your Email</label>
+        <input type="email" class="form-control" placeholder="Enter Email" required  >
+        <label>Address</label>
+        <div wicket:id="address"/>
+    </div>
+</wicket:fragment>
+
+<wicket:fragment wicket:id="convictionFragment">
+    <div class="form-group">
+    <label wicket:id="label"></label>
+    <input wicket:id="conviction" type="text" class="form-control" placeholder="What did you do?" required>
+    <label>Name</label>
+    <input wicket:id="name" type="text" class="form-control" placeholder="What is your name?" required>
+    <label style="display:block">Vehicle Type</label>
+    <input wicket:id="typeahead" type="text" class="form-control" placeholder="enter your car manufacturer" required>
+    </div>
+</wicket:fragment>
+
+
+
+<!--
+<div class="container">
+
+
+   <p>
+            <a class="btn btn-lg btn-primary" role="button">Issue</a>
+            <a class="btn btn-lg btn-default" role="button">Cancel</a>
+        </p>
+
+    <div class="jumbotron">
+        <h1>Navbar example</h1>
+        <p>This example is a quick exercise to illustrate how the default, static and fixed to top navbar work. It includes the responsive CSS and HTML, so it also adapts to your viewport and device.</p>
+        <p>To see the difference between static and fixed top navbars, just scroll.</p>
+        <p>
+            <a class="btn btn-lg btn-primary" href="../../components/#navbar" role="button">View navbar docs »</a>
+        </p>
+    </div>
+
+</div>
+-->
+
+</body></html>
+
+
+
+
+
+
+
+
+
+
+
Index: src/main/java/demo/EasyAddress.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/EasyAddress.html	(revision )
+++ src/main/java/demo/EasyAddress.html	(revision )
@@ -0,0 +1,12 @@
+<wicket:panel>
+    <wicket:enclosure child="text">
+        <input type="text" wicket:id="text" class="txt form-control"/>
+        <input wicket:id="latitude" class="lat" type="hidden"/>
+        <input wicket:id="longitude" class="lng" type="hidden"/>
+        <input wicket:id="street_address" class="street-address" type="hidden"/>
+        <input wicket:id="locality" class="city" type="hidden"/>
+        <input wicket:id="administrative_area_level_1" class="state" type="hidden"/>
+        <input wicket:id="country" class="country" type="hidden"/>
+        <input wicket:id="postal_code" class="postal-code" type="hidden"/>
+    </wicket:enclosure>
+</wicket:panel>
Index: src/main/java/demo/GpsLocation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/GpsLocation.java	(revision )
+++ src/main/java/demo/GpsLocation.java	(revision )
@@ -0,0 +1,50 @@
+
+package demo;
+
+import java.io.Serializable;
+import java.math.BigDecimal;
+
+/**
+ * @author derek.dick
+ */
+public class GpsLocation implements Serializable {
+    
+    private BigDecimal latitude;
+    private BigDecimal longitude;
+
+    public GpsLocation(BigDecimal latitude, BigDecimal longitude) {
+        this.latitude = latitude;
+        this.longitude = longitude;
+    }
+
+    public GpsLocation(Number latitude, Number longitude) {
+        this.latitude = new BigDecimal(latitude.doubleValue());
+        this.longitude = new BigDecimal(longitude.doubleValue());
+    }
+
+    public boolean isNear(GpsLocation location) {
+        return false;   //TODO
+    }
+    
+    public boolean isNear(GpsLocation location, Number threshold) {
+        return false; //TODO
+    }          
+    
+    public Double distanceFrom(GpsLocation location) {                                                                                                                                                                                                                                                               
+        // do the haversine calculation stuff here...
+        return 0.0;
+    }
+
+    public boolean isEmpty() {
+        return latitude==null || longitude==null;
+    }
+
+    public BigDecimal getLatitude() {
+        return latitude;
+    }
+
+    public BigDecimal getLongitude() {
+        return longitude;
+    }
+    
+}
Index: src/main/java/demo/ParseException.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/ParseException.java	(revision )
+++ src/main/java/demo/ParseException.java	(revision )
@@ -0,0 +1,187 @@
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 5.0 */
+/* JavaCCOptions:KEEP_LINE_COL=null */
+package demo;
+
+/**
+ * This exception is thrown when parse errors are encountered.
+ * You can explicitly create objects of this exception type by
+ * calling the method generateParseException in the generated
+ * parser.
+ *
+ * You can modify this class to customize your error reporting
+ * mechanisms so long as you retain the public fields.
+ */
+public class ParseException extends Exception {
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /**
+   * This constructor is used by the method "generateParseException"
+   * in the generated parser.  Calling this constructor generates
+   * a new object of this type with the fields "currentToken",
+   * "expectedTokenSequences", and "tokenImage" set.
+   */
+  public ParseException(Token currentTokenVal,
+                        int[][] expectedTokenSequencesVal,
+                        String[] tokenImageVal
+                       )
+  {
+    super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));
+    currentToken = currentTokenVal;
+    expectedTokenSequences = expectedTokenSequencesVal;
+    tokenImage = tokenImageVal;
+  }
+
+  /**
+   * The following constructors are for use by you for whatever
+   * purpose you can think of.  Constructing the exception in this
+   * manner makes the exception behave in the normal way - i.e., as
+   * documented in the class "Throwable".  The fields "errorToken",
+   * "expectedTokenSequences", and "tokenImage" do not contain
+   * relevant information.  The JavaCC generated code does not use
+   * these constructors.
+   */
+
+  public ParseException() {
+    super();
+  }
+
+  /** Constructor with message. */
+  public ParseException(String message) {
+    super(message);
+  }
+
+
+  /**
+   * This is the last token that has been consumed successfully.  If
+   * this object has been created due to a parse error, the token
+   * followng this token will (therefore) be the first error token.
+   */
+  public Token currentToken;
+
+  /**
+   * Each entry in this array is an array of integers.  Each array
+   * of integers represents a sequence of tokens (by their ordinal
+   * values) that is expected at this point of the parse.
+   */
+  public int[][] expectedTokenSequences;
+
+  /**
+   * This is a reference to the "tokenImage" array of the generated
+   * parser within which the parse error occurred.  This array is
+   * defined in the generated ...Constants interface.
+   */
+  public String[] tokenImage;
+
+  /**
+   * It uses "currentToken" and "expectedTokenSequences" to generate a parse
+   * error message and returns it.  If this object has been created
+   * due to a parse error, and you do not catch it (it gets thrown
+   * from the parser) the correct error message
+   * gets displayed.
+   */
+  private static String initialise(Token currentToken,
+                           int[][] expectedTokenSequences,
+                           String[] tokenImage) {
+    String eol = System.getProperty("line.separator", "\n");
+    StringBuffer expected = new StringBuffer();
+    int maxSize = 0;
+    for (int i = 0; i < expectedTokenSequences.length; i++) {
+      if (maxSize < expectedTokenSequences[i].length) {
+        maxSize = expectedTokenSequences[i].length;
+      }
+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
+      }
+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
+        expected.append("...");
+      }
+      expected.append(eol).append("    ");
+    }
+    String retval = "Encountered \"";
+    Token tok = currentToken.next;
+    for (int i = 0; i < maxSize; i++) {
+      if (i != 0) retval += " ";
+      if (tok.kind == 0) {
+        retval += tokenImage[0];
+        break;
+      }
+      retval += " " + tokenImage[tok.kind];
+      retval += " \"";
+      retval += add_escapes(tok.image);
+      retval += " \"";
+      tok = tok.next;
+    }
+    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
+    retval += "." + eol;
+    if (expectedTokenSequences.length == 1) {
+      retval += "Was expecting:" + eol + "    ";
+    } else {
+      retval += "Was expecting one of:" + eol + "    ";
+    }
+    retval += expected.toString();
+    return retval;
+  }
+
+  /**
+   * The end of line string for this machine.
+   */
+  protected String eol = System.getProperty("line.separator", "\n");
+
+  /**
+   * Used to convert raw characters to their escaped version
+   * when these raw version cannot be used as part of an ASCII
+   * string literal.
+   */
+  static String add_escapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+}
+/* JavaCC - OriginalChecksum=1e748d05e03a995e18a3765341ec04dc (do not edit this line) */
Index: src/main/java/demo/EasyTabbedPanel.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/EasyTabbedPanel.html	(revision )
+++ src/main/java/demo/EasyTabbedPanel.html	(revision )
@@ -0,0 +1,20 @@
+<wicket:panel xmlns:wicket="http://wicket.apache.org">
+    <form wicket:id="form">
+        <div wicket:id="tabsContainer" class="tab-row">
+            <span class="tab-header"><span wicket:id="header"/><p>:</p></span>
+            <ul class="tab-list">
+                <li wicket:id="tabs">
+                    <a wicket:id="link" href="#" class="tab-name"><span wicket:id="title"/></a>
+                    <div class="tab-x"><a wicket:id="delete" href="#"><i class="fa fa-times"/></a></div>
+                </li>
+            </ul>
+            <div wicket:id="add" class="tab-add "><i class="fa fa-plus-circle"/></div>
+        </div>
+        <div wicket:id="panelContainer" class="tab-panels">
+            <div wicket:id="panels">
+                <div wicket:id="panel" class="tab-content"><!-- hidden by default...only selected one shown --></div>
+            </div>
+            <div wicket:id="blankSlate" class="tab-content blank-slate"/>
+        </div>
+    </form>
+</wicket:panel>
Index: src/main/java/demo/NameResult.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/NameResult.java	(revision )
+++ src/main/java/demo/NameResult.java	(revision )
@@ -0,0 +1,40 @@
+package demo;
+
+import com.google.common.base.Preconditions;
+import com.google.common.base.Predicate;
+import com.google.common.collect.Iterables;
+
+import java.util.Collection;
+import java.util.Stack;
+
+public class NameResult extends Stack<Name> {
+
+    public Name getName() {
+        return merge();
+    }
+
+    public Collection<Name> getNames() {
+        return this;
+    }
+
+    private final Name merge() {
+        Preconditions.checkState(size()==1 || size()==2, "can't merge if there are no names or too many names : " + size());
+        if (size()==1) {
+            return get(0);
+        }
+        return get(0).merge(get(1));
+    }
+
+    public boolean isTwoPeople() {
+        return size()==2;
+    }
+
+    public boolean mayBeAmbiguous() {
+        Iterable<Name> ambiguous = Iterables.filter(this, new Predicate<Name>() {
+            @Override public boolean apply(Name name) {
+                return name.isAmbiguous();
+            }
+        });
+        return ambiguous.iterator().hasNext();
+    }
+}
Index: src/main/java/demo/MultiSelect.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/MultiSelect.java	(revision )
+++ src/main/java/demo/MultiSelect.java	(revision )
@@ -0,0 +1,63 @@
+package demo;
+
+import com.google.gson.Gson;
+import org.apache.wicket.markup.head.IHeaderResponse;
+import org.apache.wicket.markup.head.OnDomReadyHeaderItem;
+import org.apache.wicket.markup.html.form.DropDownChoice;
+import org.apache.wicket.markup.html.form.IChoiceRenderer;
+import org.apache.wicket.model.IModel;
+
+import java.util.List;
+
+public class MultiSelect extends DropDownChoice {
+    private static final String INIT_MULTISELECT_JS = "easy.multiselect.init(%s);";
+
+    public MultiSelect(String id) {
+        super(id);
+    }
+
+    public MultiSelect(String id, List choices) {
+        super(id, choices);
+    }
+
+    public MultiSelect(String id, List choices, IChoiceRenderer renderer) {
+        super(id, choices, renderer);
+    }
+
+    public MultiSelect(String id, IModel model, List choices) {
+        super(id, model, choices);
+    }
+
+    public MultiSelect(String id, IModel model, List choices, IChoiceRenderer renderer) {
+        super(id, model, choices, renderer);
+    }
+
+    public MultiSelect(String id, IModel choices) {
+        super(id, choices);
+    }
+
+    public MultiSelect(String id, IModel model, IModel choices) {
+        super(id, model, choices);
+    }
+
+    public MultiSelect(String id, IModel choices, IChoiceRenderer renderer) {
+        super(id, choices, renderer);
+    }
+
+    public MultiSelect(String id, IModel model, IModel choices, IChoiceRenderer renderer) {
+        super(id, model, choices, renderer);
+    }
+
+    @Override
+    public void renderHead(IHeaderResponse response) {
+        response.render(OnDomReadyHeaderItem.forScript(String.format(INIT_MULTISELECT_JS,new Gson().toJson(getOptions()))));
+    }
+
+    protected MultiSelectOptions getOptions() {
+        return new MultiSelectOptions();
+    }
+
+    public class MultiSelectOptions {
+        public String id = MultiSelect.this.getMarkupId();
+    }
+}
Index: src/main/java/demo/SimpleCharStream.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/demo/SimpleCharStream.java	(revision )
+++ src/main/java/demo/SimpleCharStream.java	(revision )
@@ -0,0 +1,471 @@
+/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 5.0 */
+/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
+package demo;
+
+/**
+ * An implementation of interface CharStream, where the stream is assumed to
+ * contain only ASCII characters (without unicode processing).
+ */
+
+public class SimpleCharStream
+{
+/** Whether parser is static. */
+  public static final boolean staticFlag = false;
+  int bufsize;
+  int available;
+  int tokenBegin;
+/** Position in buffer. */
+  public int bufpos = -1;
+  protected int bufline[];
+  protected int bufcolumn[];
+
+  protected int column = 0;
+  protected int line = 1;
+
+  protected boolean prevCharIsCR = false;
+  protected boolean prevCharIsLF = false;
+
+  protected java.io.Reader inputStream;
+
+  protected char[] buffer;
+  protected int maxNextCharInd = 0;
+  protected int inBuf = 0;
+  protected int tabSize = 8;
+
+  protected void setTabSize(int i) { tabSize = i; }
+  protected int getTabSize(int i) { return tabSize; }
+
+
+  protected void ExpandBuff(boolean wrapAround)
+  {
+    char[] newbuffer = new char[bufsize + 2048];
+    int newbufline[] = new int[bufsize + 2048];
+    int newbufcolumn[] = new int[bufsize + 2048];
+
+    try
+    {
+      if (wrapAround)
+      {
+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+        System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
+        buffer = newbuffer;
+
+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+        System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+        bufline = newbufline;
+
+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+        System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+        bufcolumn = newbufcolumn;
+
+        maxNextCharInd = (bufpos += (bufsize - tokenBegin));
+      }
+      else
+      {
+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+        buffer = newbuffer;
+
+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+        bufline = newbufline;
+
+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+        bufcolumn = newbufcolumn;
+
+        maxNextCharInd = (bufpos -= tokenBegin);
+      }
+    }
+    catch (Throwable t)
+    {
+      throw new Error(t.getMessage());
+    }
+
+
+    bufsize += 2048;
+    available = bufsize;
+    tokenBegin = 0;
+  }
+
+  protected void FillBuff() throws java.io.IOException
+  {
+    if (maxNextCharInd == available)
+    {
+      if (available == bufsize)
+      {
+        if (tokenBegin > 2048)
+        {
+          bufpos = maxNextCharInd = 0;
+          available = tokenBegin;
+        }
+        else if (tokenBegin < 0)
+          bufpos = maxNextCharInd = 0;
+        else
+          ExpandBuff(false);
+      }
+      else if (available > tokenBegin)
+        available = bufsize;
+      else if ((tokenBegin - available) < 2048)
+        ExpandBuff(true);
+      else
+        available = tokenBegin;
+    }
+
+    int i;
+    try {
+      if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1)
+      {
+        inputStream.close();
+        throw new java.io.IOException();
+      }
+      else
+        maxNextCharInd += i;
+      return;
+    }
+    catch(java.io.IOException e) {
+      --bufpos;
+      backup(0);
+      if (tokenBegin == -1)
+        tokenBegin = bufpos;
+      throw e;
+    }
+  }
+
+/** Start. */
+  public char BeginToken() throws java.io.IOException
+  {
+    tokenBegin = -1;
+    char c = readChar();
+    tokenBegin = bufpos;
+
+    return c;
+  }
+
+  protected void UpdateLineColumn(char c)
+  {
+    column++;
+
+    if (prevCharIsLF)
+    {
+      prevCharIsLF = false;
+      line += (column = 1);
+    }
+    else if (prevCharIsCR)
+    {
+      prevCharIsCR = false;
+      if (c == '\n')
+      {
+        prevCharIsLF = true;
+      }
+      else
+        line += (column = 1);
+    }
+
+    switch (c)
+    {
+      case '\r' :
+        prevCharIsCR = true;
+        break;
+      case '\n' :
+        prevCharIsLF = true;
+        break;
+      case '\t' :
+        column--;
+        column += (tabSize - (column % tabSize));
+        break;
+      default :
+        break;
+    }
+
+    bufline[bufpos] = line;
+    bufcolumn[bufpos] = column;
+  }
+
+/** Read a character. */
+  public char readChar() throws java.io.IOException
+  {
+    if (inBuf > 0)
+    {
+      --inBuf;
+
+      if (++bufpos == bufsize)
+        bufpos = 0;
+
+      return buffer[bufpos];
+    }
+
+    if (++bufpos >= maxNextCharInd)
+      FillBuff();
+
+    char c = buffer[bufpos];
+
+    UpdateLineColumn(c);
+    return c;
+  }
+
+  @Deprecated
+  /**
+   * @deprecated
+   * @see #getEndColumn
+   */
+
+  public int getColumn() {
+    return bufcolumn[bufpos];
+  }
+
+  @Deprecated
+  /**
+   * @deprecated
+   * @see #getEndLine
+   */
+
+  public int getLine() {
+    return bufline[bufpos];
+  }
+
+  /** Get token end column number. */
+  public int getEndColumn() {
+    return bufcolumn[bufpos];
+  }
+
+  /** Get token end line number. */
+  public int getEndLine() {
+     return bufline[bufpos];
+  }
+
+  /** Get token beginning column number. */
+  public int getBeginColumn() {
+    return bufcolumn[tokenBegin];
+  }
+
+  /** Get token beginning line number. */
+  public int getBeginLine() {
+    return bufline[tokenBegin];
+  }
+
+/** Backup a number of characters. */
+  public void backup(int amount) {
+
+    inBuf += amount;
+    if ((bufpos -= amount) < 0)
+      bufpos += bufsize;
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.Reader dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = buffersize;
+    buffer = new char[buffersize];
+    bufline = new int[buffersize];
+    bufcolumn = new int[buffersize];
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.Reader dstream, int startline,
+                          int startcolumn)
+  {
+    this(dstream, startline, startcolumn, 4096);
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.Reader dstream)
+  {
+    this(dstream, 1, 1, 4096);
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || buffersize != buffer.length)
+    {
+      available = bufsize = buffersize;
+      buffer = new char[buffersize];
+      bufline = new int[buffersize];
+      bufcolumn = new int[buffersize];
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    bufpos = -1;
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader dstream, int startline,
+                     int startcolumn)
+  {
+    ReInit(dstream, startline, startcolumn, 4096);
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader dstream)
+  {
+    ReInit(dstream, 1, 1, 4096);
+  }
+  /** Constructor. */
+  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+    this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
+                          int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+    this(dstream, encoding, startline, startcolumn, 4096);
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.InputStream dstream, int startline,
+                          int startcolumn)
+  {
+    this(dstream, startline, startcolumn, 4096);
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+    this(dstream, encoding, 1, 1, 4096);
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.InputStream dstream)
+  {
+    this(dstream, 1, 1, 4096);
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                          int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+                          int startcolumn, int buffersize)
+  {
+    ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(dstream, encoding, 1, 1, 4096);
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream)
+  {
+    ReInit(dstream, 1, 1, 4096);
+  }
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                     int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(dstream, encoding, startline, startcolumn, 4096);
+  }
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+                     int startcolumn)
+  {
+    ReInit(dstream, startline, startcolumn, 4096);
+  }
+  /** Get token literal value. */
+  public String GetImage()
+  {
+    if (bufpos >= tokenBegin)
+      return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+    else
+      return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                            new String(buffer, 0, bufpos + 1);
+  }
+
+  /** Get the suffix. */
+  public char[] GetSuffix(int len)
+  {
+    char[] ret = new char[len];
+
+    if ((bufpos + 1) >= len)
+      System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+    else
+    {
+      System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                        len - bufpos - 1);
+      System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+    }
+
+    return ret;
+  }
+
+  /** Reset buffer when finished. */
+  public void Done()
+  {
+    buffer = null;
+    bufline = null;
+    bufcolumn = null;
+  }
+
+  /**
+   * Method to adjust line and column numbers for the start of a token.
+   */
+  public void adjustBeginLineColumn(int newLine, int newCol)
+  {
+    int start = tokenBegin;
+    int len;
+
+    if (bufpos >= tokenBegin)
+    {
+      len = bufpos - tokenBegin + inBuf + 1;
+    }
+    else
+    {
+      len = bufsize - tokenBegin + bufpos + 1 + inBuf;
+    }
+
+    int i = 0, j = 0, k = 0;
+    int nextColDiff = 0, columnDiff = 0;
+
+    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
+    {
+      bufline[j] = newLine;
+      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
+      bufcolumn[j] = newCol + columnDiff;
+      columnDiff = nextColDiff;
+      i++;
+    }
+
+    if (i < len)
+    {
+      bufline[j] = newLine++;
+      bufcolumn[j] = newCol + columnDiff;
+
+      while (i++ < len)
+      {
+        if (bufline[j = start % bufsize] != bufline[++start % bufsize])
+          bufline[j] = newLine++;
+        else
+          bufline[j] = newLine;
+      }
+    }
+
+    line = bufline[j];
+    column = bufcolumn[j];
+  }
+
+}
+/* JavaCC - OriginalChecksum=c5f631723f87aa8981935f7197906334 (do not edit this line) */
